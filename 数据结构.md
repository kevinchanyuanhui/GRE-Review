## 第1章：绪论

### 1.2 算法和算法平均

#### 1.2.2 算法效率的度量

1. **时间复杂度**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2011-1,2012-1,2013-1,2014-1,2017-1</font>

&emsp;&emsp;一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记为$T(n)$，它是该算法问题规模的$n$的函数，时间复杂度主要分析$T(n)$的数量级。算法中基本运算(最深层循环内的语句)的频度与$T(n)$同数量级，因此通常采用算法中基本运算频度$f(n)$来分析算法的时间复杂度。因此，算法的时间复杂度记为
$$
T(n)=O(f(n))
$$
式中，O的含义是$T(n)$的数量级，其严格的数学定义是：若$T(n)$和$f(n)$是定义在整数集合上的两个函数，则存在正常数$C$和$n_0$，使得当$n\ge n_0$时，都满足$0 \le T(n) \le Cf(n)$。

&emsp;&emsp;算法的时间复杂度不仅依赖于问题的规模$n$，还取决于待输入的数据的性质(如输入数据元素的初始状态)。

- **三种时间复杂度**

**（1）最坏时间复杂度**：指在最坏的情况下，算法的时间复杂度

**（2）平均时间复杂度**：指所有可能输入实例在等概率出现的情况下，算法的期望运行时间

**（3）最好时间复杂度**：指在最好的情况下，算法的时间复杂度

- **加法规则与乘法法则**

![1.2.2-1](./数据结构/1.2.2-1.png)

- **常见的时间复杂度**

$$
O(1)<O(\log_2n)<O(n)<O(n\log_2 n) < O(n^2)<O(2^n)<O(n!)<O(n^n)
$$

2. **空间复杂度**

&emsp;&emsp;算法的空间复杂度$S(n)$定义为该算法所耗费的存储空间，它是问题规模$n$的函数。渐进空间复杂度也简称为空间复杂度，记为$S(n)=O(g(n))$。

&emsp;&emsp;一个上机程序除需要存储空间来存放本身所需要的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储为实现计算所需的一些信息的辅助空间，若输入的数据所占空间只取决于问题本身而与算法无关，则只需分析除输入和程序外的额外空间。

**【注】**：算法原地工作是指算法所需的辅助空间为常量，即$O(1)$。



## 第2章：线性表

### 2.1 线性表的定义和基本操作

#### 2.1.1 线性表的定义

&emsp;&emsp;线性表示具有相同数据类型的$n(n \ge 0)$个数据元素的有限序列，其中$n$为表长，当$n=0$时线性表是一个空表。若用$L$命名线性表，则其一般表示为
$$
L =(a_1,a_2,\dots,a_i,\dots,a_n)
$$
$a_1$是“第一个”数据元素，又称为表头元素，$a_n$是”最后一个“元素，又称为表尾元素。除第一个元素外，每个元素有且仅有一个直接前驱。除最后一个元素以外，每个元素都有且仅有一个直接后继。以上都是线性表的逻辑特性。

- **线性表的特点**

（1）表中元素有限

（2）表中元素具有逻辑上的顺序性，在序列中各个元素排序有其先后次序

（3）表中元素都是数据元素，每个元素都是单个元素

（4）表中元素的数据类型都相同，这意味着每个元素占有相同的大小的存储空间

（5）表中元素具有抽象性，即仅讨论元素之间的逻辑关系，而不讨论元素究竟表示什么内容



#### 2.1.2 线性表的基本操作

- InitList(&L)：**初始化表**。返回一个空的线性表。
- Length(L)：**求表长**。返回线性表L的长度，即L中元素的个数。
- LocateElem(L,e)：**按值查找操作**。在表L中查找具有给定关键字值的元素。
- GetElem(L,i)：**按位查找操作**。获取表L中的第i个位置的元素。
- ListInsert(&L,i,e)：**插入操作**。在表L中的第i个位置插入指定元素e。
- ListDelect(&L,i,&e)：**删除操作**。删除表L中的第i个位置的元素，并用e返回删除元素的值。
- PrintList(L)：**输出操作**。按前后的输出顺序输出线性表L的所有元素值。
- Empty(L)：**判空操作**。若L为空表，则返回ture，否则返回false。
- DestroyList(&L)：**销毁操作**。销毁线性表，并释放线性表L所占用的内存空间。 





### 2.2 线性表的顺序表示

#### 2.2.1 顺序表的定义

&emsp;&emsp;线性表的顺序存储又称为**顺序表**。它是用一组地址连续的存储单元依次存储线性表中的数据单元，从而使得逻辑上相邻的两个元素在物理位置上也相邻。

![2.2.1-1](./数据结构/2.2.1-1.png)

- 假定线性表中的元素类型为ElemType，则线性表的顺序存储类型描述为

```c
#define MaxSize 50	//定义线性表的最大长度
typedef struct{
    ElemType data[MaxSize];	//顺序表的元素
    int length;				//顺序表当前长度
}SqList;					//顺序表的类型定义
```

- 动态数组分配

```c
#define InitSize 100	//表长度的初始定义
typedef struct{
    ElemType *data;		//指示动态分配数组的指针
    int	MaxSize,length	//数组的最大容量和当前个数
}SqList;				//顺序表的类型定义
```

C的初始动态分配语句

```
L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize)
```

C++初始动态分配语句

```c++
L.data = new ElemType(InitSize);
```



### 2.3 线性表的链式表示

&emsp;&emsp;顺序表的插入、删除操作需要移动大量的元素，影响了运行效率，由此引入了线性表的链式存储。链式存储不要求连续的存储单元，即它不要求逻辑上相邻的两个元素物理上也相邻。对线性表的插入、删除不需要移动元素，只需修改指针即可。

#### 2.3.1 单链表的定义

&emsp;&emsp;线性表的链式存储又称为单链表，它是通过任意一组存储单元来存储线性表中的数据元素。

- **单链表结点类型的描述**

```c++
typedef struct LNode{	//定义单链表结点类型
    ElemType data;		//数据域
    struct LNode *next;	//指针域
}LNode,*LinkList;
```

&emsp;&emsp;通常用一个**头指针**来标识一个链表，如单链表$L$，头指针为NULL时表示一个空表，为了方便，在单链表第一个结点前附加一个结点，称为**头结点**。头结点的数据域不含有任何信息，指针域指向线性表的第一个元素结点。

![2.3.1-1](./数据结构/2.3.1-1.png)

- **头指针和头结点的区分**

&emsp;&emsp;不管带不带头结点，头指针始终指向链表的第一个结点，而头结点是带头结点的链表中的第一个结点，结点内不存储信息。

- **引入头结点后的优点**：

（1）由于开始结点的位置被放置在头结点的指针域中，所以在链表的第一个位置上的操作和在表的其它位置上的操作一致，无需特殊处理。

（2）无论链表是否为空，其头指针都指向头结点而非空指针，因此空表和非空表的处理也得到了统一。



#### 2.3.3 双链表

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2016-2</font>

&emsp;&emsp;单链表结点中只有一个指向其后继的指针，使得单链表只能从结点依次顺序地向后遍历。要访问某个结点的前驱结点(插入、删除操作时)，只能从头结点开始遍历，访问后继结点的时间复杂度为$O(1)$，访问前驱结点的复杂度为$O(n)$。

&emsp;&emsp;为了克服单链表的上述缺点，引入了双链表，双链表结点中有两个指针prior和next，分别指向其前驱结点和后继结点，如图：

<img src="./数据结构/2.3.3-1.png" alt="2.3.3-1" style="zoom:80%;" />

&emsp;&emsp;双链表结点类型的描述如下：

```c
typedef struct DNode{			//定义双链表结点类型
    ElemType data;				//数据域
    struct DNode *prior,*next;	//前驱和后继指针
}DNode,*DLinkList;
```

&emsp;&emsp;双链表的插入、删除结点的算法复杂度均为$O(1)$。





####2.3.5 静态链表

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2016-1</font>

&emsp;&emsp;静态链表借助数组来描述线性表的链式存储结构，结点也有数据域data和指针域next，与前面所讲的链表中的指针不同的是，这里的指针是结点的相对地址(数组下标)，又称游标。

&emsp;&emsp;和顺序表一样，静态链表也要预先分配一块连续的内存空间。

<img src="./数据结构/2.3.5-1.png" alt="2.3.5-1" style="zoom:80%;" />

&emsp;&emsp;静态链表结构类型的描述如下：

```c
#define MaxSize 50		//静态链表的最大长度
typedef struct{			//静态链表结构数据类型定义
    ElemType data;		//存储数据元素
    int next;			//下一个元素的数组下标
}SLinkList[MaxSize];
```



## 第3章：栈和队列

### 3.1 栈(Stack)

#### 3.1.1 栈的基本概念

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-2,2010-1,2011-2，2013-2,2015-1,2017-2</font>

1. **栈的定义**

&emsp;&emsp;栈只允许在一端进行插入或删除的线性表。栈的操作特性可归纳为**后进先出(Last In First Out, LIFO)**。

2. **栈常见的基本操作**

- **InitQueue(&S)**：初始化一个空栈S。
- **StackEmpty(S)**：判断栈空，若栈S为空返回true，否则返回false。
- **Push(&S,x)**：进栈，若栈S未满，将x加入，使之成为新的栈顶。
- **Pop(&S,&x)**：出栈，若栈S非空，则弹出栈顶元素，并用x返回。
- **GetTop(S,&x)**：读栈顶元素，若栈S非空，则用x返回栈顶元素。
- **ClearStack(&S)**：销毁栈，并释放栈S占用的存储空间



#### 3.1.2 栈的顺序存储结构



3. **共享栈**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2016-3</font>

&emsp;&emsp;利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数据空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸，如图所示：

<img src="./数据结构/3.1.2-1.png" alt="3.1.2-1" style="zoom:85%;" />

&emsp;&emsp;两个栈的栈顶指针都指向栈顶元素，top0=-1时0号栈为空，top1=MaxSize时1号栈为空；仅当两个栈顶指针相邻(top1-top0=1)时，判断为栈满。当0号栈进栈时，top0先加1再赋值，1号栈进栈时top1先减1再赋值；出栈则相反。

&emsp;&emsp;共享栈取数据的时间复杂度为$O(1)$。



### 3.2 队列(Queue)

#### 3.2.1 队列的基本概念

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-1/2,2010-2,2011-3</font>

1. **队列的定义**

&emsp;&emsp;队列只允许在表的一端进行插入，而在表的另一端进行删除。队列的操作特性可归纳为**先进先出(First In First Out, FIFO)**。

2. **队列常见的基本操作**

- **InitQueue(&Q)**：初始化队列，构造一个空队列Q。
- **QueueEmpty(Q)**：判断队空，若队列Q为空返回true，否则返回false。
- **EnQueue(&Q,x)**：入队，若队列Q未满，将x加入，使之成为新的队尾。
- **DeQueue(&Q,&x)**：出队，若队列Q非空，删除对头元素，并用x返回。
- **GetHead(Q,&x)**：读队头元素，若队列Q非空，则将对头元素赋值给x。

#### 3.2.2 队列的顺序存储结构

1. **队列的顺序存储**

&emsp;&emsp;队列的顺序存储实现是指分配一块连续的存储单元存放队列中的元素，并附设**两个指针front和rear分别指示对头元素和队尾元素的位置**。设**队头指针指向队头元素，队尾指针指向队尾元素的下一个位置(也可以让rear指向队尾元素，front指向队头元素的前一个位置)**。

<img src="./数据结构/3.2.2-1.png" alt="3.2.2-1" style="zoom:80%;" />

- **队列的顺序存储类型描述**

```c
#define MaxSize 50			//定义队列中元素的最大个数
typedef struct{
    ElemType data[MaxSize];	//存放队列元素
    int front,rear;
}SeQueue;
```

​	① 初始状态(队空条件)：Q.front == Q.rear == 0

​	② 进队操作，队不满时，先送值到队尾元素，再将队尾指针加1。

​	③ 出队操作，队不空时，先取队头元素值，再将队头指针加1。

2. **循环队列**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2014-3</font>

<img src="./数据结构/3.2.2-2.png" alt="3.2.2-2" style="zoom:80%;" />

- **区分队空还是队满的情况**

<img src="./数据结构/3.2.2-3.png" alt="3.2.2-3" style="zoom:80%;" />

<img src="./数据结构/3.2.2-4.png" alt="3.2.2-4" style="zoom:80%;" />

<img src="./数据结构/3.2.2-5.png" alt="3.2.2-5" style="zoom:80%;" />

3. **循环队列的操作**

**（1）初始化**

```c
void InitQueue(SqQueue &Q){
	Q.rear = Q.front = 0;			//初始化队首、队尾指针
}
```

**（2）判队空**

```c
bool isEmpty(SqQueue Q){
	if(Q.rear == Q.front) return true;		//队空条件
    else return false;
}
```

**（3）入队**

```c
bool EnQueue(SqQueue &Q,ElemType x){
	if((Q.rear+1)%MaxSize == Q.front)	return false;	//队满
    Q.data[Q.rear] = x;
    Q.rear = (Q.rear+1)%MaxSize;						//队尾指针加1取模
    return true;
}
```

**（4）出队**

```c
bool DeQueue(SqQueue &Q,ElemType &x){
	if(Q.rear == Q.front) return false;					//队空，报错
    x = Q.data[Q.front];
    Q.front = (Q.front+1)%MaxSize;						//队头指针加1取模
}
```



### 3.3 栈和队列的应用

#### 3.3.1 中缀表达式转后缀表达式

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2012-2,2014-2</font>

- **算法流程**

1、任何中缀表达式都由运算数，运算符，括号（大，中，小），这三部分组成。

2、从中缀表达式的左边开始扫描，若遇到运算数时，则直接将其输出，不压入堆栈。

3、若遇到左括号，则将其压栈。

4、若遇到右括号，表达括号内的中缀表达式已经扫描完毕。这时需将栈顶的运算符依次弹出并输出，直至遇到左括号，左括号弹出但不输出。

5、若遇到的是运算符：

​	a、如果该运算符的优先级大于栈顶运算符的优先级时，将其压栈

​	b、如果该运算符的优先级小于栈顶运算符的优先级时，将栈顶运算符弹出并输出，接着和新的栈顶运算符比较，若大于，则将其压栈，若小于，继续将栈顶运算符弹出并输出......(一直递归下去，直至运算符大于栈顶运算符为止)。

6、最后一步，若扫描到中缀表达式的末尾[即扫描结束]，若堆栈中还有存留的运算符依次弹出并输出即可。

>  比如将:2*(9+6/3-5)+4转化为后缀表达式2 9 6 3 / +5 - * 4 + 
>
> （1）out：2                                                                          stack：
>
> （2）out：2                                                                          stack：*
>
> （3）out：2                                                                          stack： *  （
>
> （4）out：2    9                                                                    stack ：*   （
>
> （5）out：2    9                                                                    stack ：*   （ +     
>
> ​																								注：**在堆栈中括号的优先级最低**
>
> （6）out：2    9   6                                                               stack ：*   （ +
>
> （7）out ：2   9   6                                                               stack ：*   （ +   /
>
> （8）out ：2   9   6    3                                                         stack ：*   （ +  /
>
> （9）out ：2   9   6   3    /                                                     stack ：*   （ +   
>
> （10）out： 2   9   6   3    /   +                                              stack : *     (   
>
> （11）out：2   9   6  3   /    +                                                stack : *     (   -
>
> （12）out : 2    9   6  3   /    +   5                                           stack : *    （ -   遇到了右括号
>
> （13）out：2   9   6  3   /   +    5   -                                       stack：*   （      
>
> （14）out：2  9   6   3   /   +    5   -                                       stack：*
>
> （15）out：2  9   6   3   /   +   5    -                                       stack ：*    括号弹出但不输出
>
> （16）out ：2   9    6   3   /   +   5   -   *                                 stack  :           遇到了+
>
> （17）out：2   9  6   3   /  +   5   -    *                                    stack ：+
>
> （18）out：2  9  6   3   /  +   5  -    *   4                                 stack  : +
>
> （19）out：2   9   6   3   /  +  5  -  *  4  +                              stack ：
> 





## 第4章：树与二叉树

### 4.1 树的基本概念

#### 4.1.3 树的性质

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2010-5</font>

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2016-42</font>

（1）树中的**结点数等于所有结点度数加1**。

（2）度为$m$的树中第$i$层上至多有$m^{i-1}$个结点($i \geq 1$)

（3）高度为$h$的$m$叉树至多有$(m^h-1)/(m-1)$个结点，最少含有$(h-1)m+1$个结点。

**【注1】**推导公式(至多)：$S=m^{k-1}+m^{k-2}+\dots+m+1=(m^h-1)/(m-1)$

**【注2】**最少的情况是第一层只有根结点，第2到第h-1层仅含有一个分支结点和m-1叶子结点，第h层含有m个叶子结点。即除根外第2到第h层中每层的结点数为m。

（4）具有$n$个结点的$m$叉树的最小高度为$\biggl\lceil \log_m(n(m-1)+1) \biggr\rceil\qquad$



![4.1.2-1](./数据结构/4.1.2-1.png)

### 4.2 二叉树的概念

#### 4.2.1 二叉树的定义及其主要特性

1. **二叉树的定义**

&emsp;&emsp;二叉树是另一种树形结构，其特点是每个结点至多只有两颗子树(即二叉树不存在度大于2的结点)，并且二叉树的子树有左右之分，其次序不能颠倒。

- **二叉树与度为2的有序树的区别：**

① 度为2的树至少有3个结点，而二叉树可以为空。

② **度为2的有序树的孩子结点的左右次序是相对于另一个孩子结点而言的**，若某个结点只有一个孩子结点，则这个孩子结点就无须区分其左右次序，而二叉树无论其孩子数是否为2，均需确认其左右次序，即**二叉树的结点次序不是相对另一结点而言，而是确定的**。



2. **几种特殊的二叉树**

（1）**满二叉树**：

&emsp;&emsp;一颗高度为$h$，且含有$2^h-1$个结点的二叉树称为满二叉树。**除叶子结点外每个结点的度均为2**。

可以对满二叉树按层序编号，约定编号从根节点(根结点编号为1)起，自上而下：

① 编号为$i$的结点，若有双亲，其双亲为$\lfloor i/2  \rfloor$。

② 编号为$i$的结点，若有左孩子，则左孩子为$2i$；若有右孩子，则右孩子为$2i+1$。

（2）**完全二叉树**：

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-5,2011-4</font>

&emsp;&emsp;设一个高度为$h$、有$n$个结点的二叉树，当且仅当其每个结点都与高度为$h$的满二叉树中编号为1~$n$的结点一一对应时，称为完全二叉树。

① 若$i \le \lfloor n/2  \rfloor$，则结点$i$为分支结点，否则为叶子结点。

② 叶子结点只可能在层次最大的两层上出现。对于最大层中的叶子结点，都依次排序在该层最左边的位置上。

③ **若有度为1的结点，则只可能有一个，且该结点只有左孩子而无右孩子**。

④ 按层序编号后，一旦出现某结点(编号为$i$)为叶子结点或只有左孩子，则编号大于$i$的结点均为叶子结点。

⑤ 若$n$为奇数，则每个分支结点都有左子女和右子女；若$n$为偶数，则编号最大的分支结点($n/2$)只有左子女，没有右子女，其余分支结点左右子女都有。

<img src="./数据结构/4.2.1-1.png" alt="4.2.1-1" style="zoom:80%;" />



3. **二叉树的性质**

1）非空二叉树上的叶子结点数等于度为2的结点数加1，即$n_0=n_2+1$。

> 设度为0、1和2的结点个数分别为$n_0$、$n_1$和$n_2$，结点总数为$n=n_0+n_1+n_2$，再看二叉树中的分支数，除根结点外，其余结点都有一个分支进入，设$B$为分支总数，则$n=B+1$，由于这些分支是由度为1或2的结点射出的，所以有$B=n_1+n_2$，于是有
>
> $n_0+n_1+n_2=n_1+2n_2+1$，则$n_0=n_2+1$

2）非空二叉树上第$k$层上至多有$2^{k-1}$个结点($k\ge1$)

3）高度为$h$的二叉树至多有$2^h-1$个结点($h\ge1$)

4）对完全二叉树按从上到下、从左到右顺序依次编号1、2、$\dots$，$n$，则有如下关系：

​	① 当$i>1$时，结点$i$的双亲结点编号为$\lfloor i/2  \rfloor$，当$i$是偶数时，它是双亲结点的左孩子；当$i$是奇数时，它是双亲结点的右孩子。

​	② 当$2i\le n$时，结点$i$的左孩子编号为$2i$，否则无左孩子；当$2i+1\le n$时，结点$i$的右孩子编号为$2i+1$，否则无右孩子。

​	③ 结点$i$所在的层次(深度)为$\lfloor \log_2i \rfloor+1$

​	④ 具有$n$个($n > 0$)结点的完全二叉树的高度为$\lceil \log_2(n+1) \rceil$或$\lfloor \log_2n \rfloor+1$

### 4.3 二叉树的遍历和线索二叉树

#### 4.3.1 二叉树的遍历

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-3,2011-5,2012-3,2015-2,2017-4/5</font>

1. **先序遍历(NLR)**

若二叉树为空，则什么也不做，否则：

1）访问根结点；

2）先序遍历左子树；

3）先序遍历右子树；

```c
void PreOrder(BitTree T) {
	if(T!=NULL) {
		visit(T);				//访问根节点
        PreOrder(T->lchild);	//递归遍历左子树
        PreOrder(T->rcild);		//递归遍历右子树
	}
}
```



2. **中序遍历(LNR)**

若二叉树为空，则什么也不做，否则：

1）中序遍历左子树；

2）访问根结点；

3）中序遍历右子树；

```c
void InOrder(BitTree T) {
	if(T!=NULL) {
        InOrder(T->lchild);		//递归遍历左子树
        visit(T);				//访问根节点
        InOrder(T->rcild);		//递归遍历右子树
	}
}
```



3. **后序遍历(LRN)**

若二叉树为空，则什么也不做，否则：

1）后序遍历左子树；

2）后序遍历右子树；

3）访问根结点；

```c
void PostOrder(BitTree T) {
	if(T!=NULL) {
        PostOrder(T->lchild);		//递归遍历左子树
        PostOrder(T->rcild);		//递归遍历右子树
        visit(T);					//访问根节点
	}
}
```

4. **递归算法和非递归算法的转换**

&emsp;&emsp;借助栈，可以将二叉树的递归遍历算法转换为非递归算法。下面以中序遍历为例给出中序遍历的非递归算法。先扫描(非访问)根结点的所有左结点并将它们一一入栈，然后出栈一个结点\*p(显然结点\*p没有左孩子或左孩子结点均已被访问过)，访问他。然后扫描该结点的右孩子结点，将其进栈，再扫描该右孩子结点的所有左结点并一一进栈，如此继续，直到栈空为止。

- **算法实现**

```c
void InOrder2(BiTree T){
    //二叉树中序遍历的非递归算法，算法需要借助一个栈
    InitStack(S); BitTree p = T;	//初始化栈，p是遍历指针
    while(p||!IsEmpty(S)){			//栈不空或p不空时循环
        if(p){						//根指针进栈，遍历左子树
        	Push(S,p);
            p=p->lchild;
        }else{
            Pop(S,p);				//根指针退栈。访问根结点，遍历右子树
            visit(p);				//退栈，访问根结点
            p=p->right;				//再向右子树走
        }
    }
}
```



5. **层次遍历**

&emsp;&emsp;要进行层次遍历，需要借助一个队列。先将二叉树根结点入队，然后出队，访问该结点，若它有左子树，则将左子树根结点入队；若它有右子树，则将右子树根结点如队，对出队结点访问，如此反复，直到队列为空。

<img src="./数据结构/4.3.1-1.png" alt="4.3.1-1" style="zoom:80%;" />

```c
void LevelOrder(BiTree T){
    InitQueue(Q);		//初始化辅助队列
    BitTree P;
    EnQueue(Q,T);		//将根结点入队
    while(!IsEmpty(Q)){ //队列不为空
        DeQueue(Q,p);	//队头元素出队
        visit(p);		//访问当前p所指向的结点
        if(p->lchild!=NULL)
            EnQueue(Q,p->lchild);  //左子树不空，则左子树入队列
        if(p->rchild!=NULL)
            EnQueue(Q,p->rchild);  //右子树不空，则左子树入队列
    }
}
```





6. **由遍历序列构造二叉树**

（1）**先序遍历**和**中序遍历**可以唯一确定一颗二叉树。

（2）**后序遍历**和**中序遍历**可以唯一确定一颗二叉树。

（3）**层序遍历**和**中序遍历**可以唯一确定一颗二叉树。

（4）**前序遍历**和**中序遍历**不能唯一确定一颗二叉树，但是可以确定二叉树中结点的祖先关系

**【注】**当两个结点的前序序列为XY与后序序列为YX时，则X为Y的祖先。



#### 4.3.2 线索二叉树

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2010-3,2013-5,2014-4</font>

> 在有$n$个结点的二叉树中，有$n+1$个空指针。这是因为每个叶子结点有2个空指针，而每个度为1的结点有1个空指针，总的空指针为$2n_0+n_1$，又$n_0=n_2+1$，所以总的空指针为：
> $$
> n_0+n_1+n_2 = n+1
> $$

【注】：$n_0 = n_2 + 1$怎么来的？

&emsp;&emsp;在二叉线索树中规定：**若无左子树，令lchild指向其前驱点**；**若无右子树，令rchild指向其后继结点**。还需要增加两个标志域表明当前指针对象是指向左(右)子结点还是指向直接前驱(后继)。

![4.3.2-1](./数据结构/4.3.2-1.png)

其中，标志域的含义如下：

![4.3.2-2](./数据结构/4.3.2-2.png)

- **线索二叉树的存储结构描述**

```c
typedef struct ThreadNode{
    ElemType data;	//数据元素
    struct ThreadNode *lchild,*rchild;	//左、右孩子指针
    int ltag,rtag;	//左、右线索标志
}ThreadNode,*ThreadNode;
```



### 4.4 树、森林

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2016-5</font>



#### 4.4.2 树、森林与二叉树的转换

1. **树$\rightarrow$二叉树**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-6,2011-6</font>

**规则**：每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻兄弟结点，可表示为**“左孩子右兄弟”**。由于根结点没有兄弟，所以由树转换而得到的二叉树没有右子树。

<img src="./数据结构/4.4.2-1.png" alt="4.4.2-1" style="zoom:90%;" />

2. **森林$\rightarrow$二叉树**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2014-5</font>

将森林转换为二叉树的步骤是：

（1）先把每棵树转换为二叉树；

（2）第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子结点，用线连接起来。当所有的二叉树连接起来后得到的二叉树就是由森林转换得到的二叉树。

<img src="./数据结构/4.4.2-2.png" alt="4.4.2-2" style="zoom:75%;" />

3. **二叉树$\rightarrow$树**

二叉树转换为树是树转换为二叉树的逆过程，其步骤是：

（1）若某结点的左孩子结点存在，将左孩子结点的右孩子结点、右孩子结点的右孩子结点……都作为该结点的孩子结点，将该结点与这些右孩子结点用线连接起来；

（2）删除原二叉树中所有结点与其右孩子结点的连线；

（3）整理（1）和（2）两步得到的树，使之结构层次分明。

<img src="./数据结构/4.4.2-3.png" alt="4.4.2-3" style="zoom:75%;" />

4. **二叉树$\rightarrow$森林**

二叉树转换为森林比较简单，其步骤如下：

（1）先把每个结点与右孩子结点的连线删除，得到分离的二叉树；

（2）把分离后的每棵二叉树转换为树；

（3）整理第（2）步得到的树，使之规范，这样得到森林。

![4.4.2-4](./数据结构/4.4.2-4.png)



###4.5 树与二叉树的应用

#### 4.5.1 二叉排序树

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2011-7,2013-6</font>

1. **二叉排序树的定义**

&emsp;&emsp;**二叉排序树(BST)**，也称为**二叉查找树**。二叉排序树或者是一颗空树，或者是一颗具有下列特性的非空二叉树：

​	1）若左子树非空，则左子树上所有结点的关键字均小于根结点的关键字。

​	2）若右子树非空，则右子树上所有结点的关键字均大于根结点的关键字。

​	3）左、右子树本身也是一颗二叉排序树。

对二叉排序树进行**中序遍历**可以得到一个**从小到大**的序列，如图，得到的序列为123468。

![4.5.1-1](./数据结构/4.5.1-1.png)



#### 4.5.2 平衡二叉树(AVL)

1. **定义**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-4,2010-4,2012-4,2013-3,2015-4</font>

&emsp;&emsp;为了避免树的增长过快，降低**二叉排序树**的性能，规定在插入和删除二叉树结点时，要保证任意结点的左、右子树高度差的绝对值不超过1，这样的二叉树称为**平衡二叉树(Balanced Binary Tree)**，简称为**平衡树(AVL)**。

2. **平衡二叉树的插入与调整**

   插入的规则按照排序树的规则，当插入导致平衡二叉树不平衡时，需要动态调整平衡二叉树。
   
   **1）LL平衡旋转(右单旋转)**

![4.5.2-1](./数据结构/4.5.2-1.png)

​		**2）RR平衡旋转(左单旋转)**

![4.5.2-2](./数据结构/4.5.2-2.png)

​		**3）LR平衡旋转(先左后右双旋转)**

![4.5.2-3](./数据结构/4.5.2-3.png)

​		**4）RL平衡旋转(先右后左旋转)**

![4.5.2-4](./数据结构/4.5.2-4.png)

#### 4.5.3 哈夫曼树和哈夫曼树编码

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2010-6,2013-4,2015-3,2017-6</font>

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2012-41</font>

1. **哈夫曼树的定义**

&emsp;&emsp;在许多实际应用中，树中结点常常被赋予一个表示某种意义的数值，称为该结点的权。**从树根结点到任意结点的路径长度(经过的边数)与该结点上权值的乘积，称为该结点的带权路径长度**。树中**所有叶结点的带权路径长度之和**称为**该树的带权路径长度**，记为
$$
WPL = \sum_{i=1}^nw_il_i
$$
其中，$w_i$是第$i$个结点所带的权值，$l_i$是该叶子结点到根结点的路径长度。

&emsp;&emsp;在含有$n$个带权叶子结点的二叉树中，其中**带权路径长度(WPL)最小**的二叉树称为哈夫曼树，也称为**最优二叉树**。

- 例子

<img src="./数据结构/4.5.3-1.png" alt="4.5.3-1" style="zoom:80%;" />

2. **哈夫曼树的构造**

&emsp;&emsp;给定$n$个权值分别为$w_1,w_2,\dots,w_n$的结点，通过哈夫曼算法可以构造出最优二叉树，算法描述如下：

<img src="./数据结构/4.5.3-2.png" alt="4.5.3-2" style="zoom:90%;" />

从上述构造过程可以看出哈夫曼树具有如下特点：

<img src="./数据结构/4.5.3-3.png" alt="4.5.3-3" style="zoom:90%;" />

- 例子

<img src="./数据结构/4.5.3-4.png" alt="4.5.3-4" style="zoom:90%;" />

3. **哈夫曼编码**

&emsp;&emsp;对于待处理的一个字符串序列，若对每个字符用同样长度的二进制位表示，则这种编码方式为**固定长度编码**；反之，则为**可变长度编码**。可变长度编码比固定长度编码好的多，其特点是对频率高的字符赋予短编码，而对效率较低的字符赋予较长一些编码，从而使得**字符平均编码长度减短，起到压缩数据的效果**。

&emsp;&emsp;哈夫曼编码是一种是被广泛使用且非常有效的数据压缩编码。

- **前缀编码**

&emsp;&emsp;若没有一个编码是另一个编码的前缀，则这样的编码称为前缀编码。

> 例如：0、101、100是前缀编码	

- **哈夫曼编码的构造**

<img src="./数据结构/4.5.3-5.png" alt="4.5.3-5" style="zoom:90%;" />

这颗哈夫曼树的WPL为
$$
WPL = 1 \times 45 +3\times(13+12+16)+4\times(5+9)=224
$$
&emsp;&emsp;此处的WPL可视为最终编码得到二进制编码长度，共224位。若采用3位固定长度编码，则得到的二进制编码长度为300位。





## 第5章：图

### 5.1 图的基本概念

#### 5.1.1 图的定义

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-7,2010-7,2011-8,2017-7</font>

3. **简单图**

&emsp;&emsp;一个图$G$若满足：**(1)不存在重复边**；**(2)不存在顶点到自身的边**，则图$G$称为简单图。

5. **完全图**

&emsp;&emsp;在无向图，若任意两个顶点之间都存在边，则图$G$称为完全图。

​	① 含有$n$个顶点的**无向完全图**有$n(n-1)/2$条边。

​	② 含有$n$个顶点的**有向无环图**有$n(n-1)$条边。

6. **子图**

&emsp;&emsp;设有两个图$G=(V,E)$和$G'=(V',E')$，若$V'$是$V$的子集，且$E'$是$E$的子集，则称$G'$是$G$的子图。若满足$V=V'$的子图$G'$，则称为$G$的**生成子图**。

**【注】**并非$V$和$E$的任何子集都能构成$G$的子图，因为这样的子集可能不是图，即$E$的子集中的某些边关联的顶点可能不在这个$V$的子集中。

7. **连通**、**连通图**和**连通分量**

&emsp;&emsp;在无向图中，若顶点$v$到顶点$w$有路径存在，则称$v$和$w$是**连通**的。若图$G$中任意两个顶点都是连通的，则称图$G$为**连通图**，否则为非连通图。无向图中的**极大连通子图**称为**连通分量**。若一个图有$n$个顶点，并且边数小于$n-1$，则此图必是非连通图。

**【注】极大连通子图是要求连通子图包含其所有的边；极小连通子图是既要保持图连通又要使得边数最少的子图。**

8. **强连通图、强连通分量**

&emsp;&emsp;在**有向图**中，若从顶点$v$到顶点$w$和从顶点$w$到顶点$v$之间都有路径，则称这两个顶点是**强连通**的。有向图中的**极大强连通子图**称为有向图的强连通分量。

**【注】**强连通分图、强连通分量只是针对有向图而言的。**一般在无向图中讨论连通性，在有向图中讨论强连通性。**

9. **生成树、生成森林**

&emsp;&emsp;**连通图的生成树**是包含图中全部顶点的一个**极小连通子图**。若图中顶点数为$n$，则它的生成树含有$n-1$条边。生成树去掉一条边，则会变成非连通图；若加上一条边，则会形成环。

&emsp;&emsp;在非连通图中，连通分量的生成树构成了**非连通图的生成森林**。

11. **网**

这种边上带权值的图称为**带权图**，也称为**网**。

12. **稠密图、稀疏图**

&emsp;&emsp;边数很少的图称为稀疏图，反之称为稠密图。一般当图$G$满足$|E| < |V|\log|V|$时，可以将$G$视为稀疏图。

13. **路径**、**路径长度**和**回路**

&emsp;&emsp;**顶点$v_p$到顶点$v_q$之间的一条路径**是指顶点序列$v_pv_{i1}v_{i2}\dots v_{im}v_q$。路径上**边的数目**称为**路径长度**。第一个顶点和最后一个顶点相同的路径称为**回路**或**环**。

**【注】**若一个图有$n$个顶点，并且有大于$n-1$条边，则此图一定有环。

14. **简单路径**、**简单回路**

&emsp;&emsp;在**路径序列**中，**顶点不重复**出现的路径称为**简单路径**。**除第一个顶点和最后一个顶点外**，**其余顶点不重复**出现的回路称为**简单回路**。



### 5.2 图的存储及基本操作

#### 5.2.1 邻接矩阵法

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2013-7</font>

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2015-42</font>

&emsp;&emsp;所谓的邻接矩阵存储，是指一个一维数组存储图中顶点的信息，用一个二维数组存储图边的信息(即各顶点之间的邻接关系)，存储顶点之间的邻接关系的二维数组称为邻接矩阵。

&emsp;&emsp;设结点为$n$的图$G=(V,E)$的邻接矩阵A是$n \times n$的，将$G$的顶点编号为$v_i(i=1,2,\dots,n)$。

- **无权图**

<img src="./数据结构/5.2.1-1.png" alt="5.2.1-1" style="zoom:90%;" />

- **有权图**

<img src="./数据结构/5.2.1-2.png" alt="5.2.1-2" style="zoom:90%;" />

- **例子**

<img src="./数据结构/5.2.1-3.png" alt="5.2.1-3" style="zoom:80%;" />

- **图的邻接矩阵存储结构**

```c
#define MaxVertexNum 10					//顶点数目的最大值
typedef char VertexType;				//顶点的数据类型
typedef int EdgeType;					//带权图中边上权值的数据类型
typedef struct{
    VertexType Vex[MaxVertexNum];		//顶点表
    EdgeType Edge[MaxVertexNum][MaxVertexNum];
    int vexnum,arcnum;					//图当前顶点数和边数
}
```

- **注意的问题**

<img src="./数据结构/5.2.1-4.png" alt="5.2.1-4" style="zoom:90%;" />



#### 5.2.3 十字链表

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2017-3</font>

&emsp;&emsp;十字链表是**有向图**的一种链式存储结构。在十字链表中，对应于有向图中的**每条弧有一个结点**，对应**每个顶点也有一个结点**。这些结点的结构如下图所示：

<img src="./数据结构/5.2.3-1.png" alt="5.2.3-1" style="zoom:80%;" />

- **弧结点**
  - **尾域(tailvex)**：弧尾所指示的顶点
  - **头域(headvex)**：弧头指示的顶点
  - **链域(hlink)**：指向弧头所指示结点相同的下一条弧
  - **链域(tlink)**：指向弧尾所指示结点相同的下一条弧
  - **info**：指向该弧的相关信息

- **顶点结点**
  - **data**：存放顶点相关的数据信息，如顶点名称
  - **firstin**：指向以该顶点为弧头的第一个弧结点
  - **firstout**：指向以该结点为弧尾的第一个弧结点

<img src="./数据结构/5.2.3-2.png" alt="5.2.3-2" style="zoom:80%;" />

- **存储结构定义**

```c
#define MaxVertexNum 100			//图中顶点数目的最大值
typedef struct ArcNode{				//边表结点
    int tailvex,headvex;			//该弧的头尾结点
    sturct ArcNode *hlink,*tlink;	//分别指向弧头相同和弧尾相同的结点
}ArcNode;
typedef struct VNode{				//顶点表结点
	VertexType data;				//顶点信息
    ArcNode *firstin,*firstout;		//指向第一条入弧和出弧
}VNode;
typedef struct{
    VNode xlist[MaxVertexNum];		//邻接表
    int vexnum,arcnum;				//图的顶点数和弧数
}GLGraph;							//GLGraph是以十字邻接存储的图类型。
```

【注1】**图的十字链表是不唯一的，但一个十字链表表示确定一个图**。

【注2】**三元组**和**十字链表**是适用于压缩存储稀疏矩阵的两种存储结构



#### 5.2.4 邻接多重表

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2017-3</font>

&emsp;&emsp;邻接多重表示**无向图**的另一种链式存储结构。在邻接表中，容易求得顶点和边的各种信息，但是在邻接表中求两个顶点之间是否存在边而对边执行删除等操作，需要分别在两个顶点的边表中遍历，效率较低。

- 在邻接多重表中，**每条边用一个结点表示**，其结构如下：

  <img src="./数据结构/5.2.4-1.png" alt="5.2.4-1" style="zoom:80%;" />

  - **mark**：标志域，可用来标记该条边是否被搜索过
  - **ivex, jvex**：为该条边依附的两个顶点在图中的位置
  - **ilink**：指向下一条依附于顶点ivex的边
  - **jlink**：指向下一条依附于顶点jvex的边
  - **info**：指向和边相关的各种信息的指针域

- 每个顶点也用一个结点表示，它由如下所示的两个域组成

  <img src="./数据结构/5.2.4-2.png" alt="5.2.4-2" style="zoom:80%;" />

  - **data**：存储该结点的相关信息
  - **firstedge**：指示第一条依附于该顶点的边

&emsp;&emsp;在邻接多重表中，**所有依赖于同一个顶点的边串联在同一链表中**，**由于每条边依附于两个顶点，因此每个边结点同时链接在两个链表中**。

<img src="./数据结构/5.2.4-3.png" alt="5.2.4-3" style="zoom:80%;" />

```c
#define MaxVertexNum 100;				//图中顶点数目的最大值
typedef struct ArcNode{					//边表结点
    bool mark;							//访问标记
    int ivex,jvex;						//分别指向该弧的两个结点
    struct ArcNode *ilink,*jlink;		//分别指向依附两个顶点的下一条边
   	//InfoType info;					//相关信息的指针
}ArcNode;
typedef struct VNode{					//顶点表结点
    VertexType data;					//顶点信息
    ArcNode *firstedge;					//指向第一条依附该顶点的边
}VNode;
typedef struct{
    VNode xlist[MaxVertexNum];		//邻接表
    int vexnum,arcnum;				//图的顶点数和弧数
}AMLGraph;							//AMLGraph是以邻接多重表存储的图类型
```



### 5.3 图的遍历

#### 5.3.1 广度优先搜索

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2012-5,2013-8</font>

- **算法思想**

&emsp;&emsp;首先访问起始顶点v，接着由$v$出发，依次访问$v$的各个未访问过的邻接顶点$w_1,w_2,\dots,w_i$，然后依次访问$w_1,w_2,\dots,w_i$的所有未被访问过的邻接顶点；再从这些访问过的顶点出发，访问它们所有未被访问过的邻接顶点，...，依次进行下去，直到图中所有顶点都被访问过为止。

- **伪代码**

```c
bool visited[MAX_VERTEX_NUM];		//访问标记数组
void BFSTraverse(Graph G){
    //对图G进行广度优先遍历，设访问函数为visit()
    for(i = 0;i < G.vexnum;i++)
        visited[i] = FALSE;			//访问标记数组初始化
    InitQueue(Q);					//初始化辅助队列Q
    for(i = 0;i < G.vexnum;i++)		//从0号开始遍历
        if(!visited[i])				//对每个连通分量调用一次BFS
            BFS(G,i);				//vi未访问过，从vi开始BFS
}
void BFS(Graph G,int v){
    //从顶点v出发，广度优先遍历图G，算法借助一个辅助队列Q
    visit(v);						//访问初始顶点v
    visited[v] = True;				//对v做已访问标记
    Enqueue(Q,v);					//顶点v入队列
    while(!isEmpty(Q)){
        DeQueue(Q,v);				//顶点v出队列
        for(w=FirstNeighbor(G,v),w>=0;w=NextNeighbor(G,v,w)){
            if(!visited[w]){
                visit(w);
                visited[w] = TRUE;	//对顶点进行标记访问
                EnQueue(Q,w);		//顶点w入队列
            }
        }
    }
}
```

- **BFS算法性能分析**

**（1）空间复杂度**

&emsp;&emsp;无论是邻接表还是邻接矩阵，BFS算法都需要一个辅助队列Q，n个顶点均入队一次，在坏的情况下，空间复杂度为$O(|V|)$。

**（2）时间复杂度**

&emsp;&emsp;采用**邻接表**时，每个顶点均需搜索一次(或入队一次)，故时间复杂度为$O(|V|)$，在搜索任一顶点的邻接点时，每条边至少访问一次，故时间复杂度为$O(|E|)$，算法时间复杂度为$O(|V|+|E|)$。

&emsp;&emsp;采用**邻接矩阵**时每条边，查找每个顶点的邻接点所需的时间为$O(|V|)$，故算法时间复杂度为$O(|V|^2)$。

- **BFS算法实现非带权图单源最短路径问题**

&emsp;&emsp;若图$G=(V,E)$为非带权图，定义从顶点$u$到顶点$v$的最短路径$d(u,v)$为从$u$到$v$的任何路径中最少的边数；若从$u$到$v$没有通路，则$d(u,v)=\infty$。

**伪代码：**

```c
void BFS_MIN_Distance(Graph G,int u){
    //d[i]表示从u到i结点的最短路径
    for(i=0;i<G.vexnum;i++)		//初始化路径长度
        d[i] = infty;
    visited[u] = True; d[u] = 0;
    EnQueue(Q,u);
    while(!isEmpty(Q)){
        DeQueue(Q,u);			//队头元素u出队
        for(w=FirstNeighbor;w>=0;w=NextNeighbor(G,u,w)){
            if(!visited[w]){	//w为u未访问的邻接顶点
                visited[w]=Ture;	//标记已访问
                d[w] = d[u]+1;		//路径长度加1
                EnQueue(Q,w);		//顶点w入队列
            }
        }
    }
}
```

- **广度优先搜索树**

&emsp;&emsp;在广度遍历的过程中，我们可以得到一颗遍历树，称为广度优先生成树。**给定图的邻接矩阵存储表示是唯一的，故其广度优先搜索树也是唯一的，但由于邻接表存储表示不唯一，故其广度优先生成树是不唯一的**。

<img src="./数据结构/5.3.1-1.png" alt="5.3.1-1" style="zoom:80%;" />



#### 5.3.2 深度优先搜索

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2015-5,2016-6</font>

&emsp;&emsp;与广度优先搜索不同，深度优先搜索(Depth-First-Search, DFS)类似于树的先序遍历。

- **算法思想**

&emsp;&emsp;首先访问图中某一起始顶点$v$，然后由$v$出发，访问与$v$邻接且未被访问的任一顶点$w_1$，再访问与$w_1$邻接且未被访问的任一顶点$w_2$，....，重复上述过程。当不能再继续向下继续访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问，则从该点开始继续上述搜索过程，直到图中所有顶点均被访问为止。

- **算法实现**

```c
bool visited[MAX_VERTEX_NUM];		//访问标记数组
void DFSTraverse(Graph G){
    //对图G进行深度优先遍历，访问函数为visit()
    for(v=0;v<G.vexnum,++v)
        visited[v] = FALSE;			//初始化已访问标记数据
    for(v=0;v<G.vexnum;++v)
        if(!visited[v])
            DFS(G,v)
}
void DFS(Graph G,int v){
    //从顶点v出发，采用递归思想，深度优先遍历图G
    visit(v);						//访问顶点v
    visited[v] = TRUE;				//设已访问标记
    for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))
        if(!visited[w]){			//w为u尚未访问的邻近顶点
            DFS(G,w);
        }
}
```

**【注】**图的邻接矩阵表示是唯一的，但对于邻接表来说，若边的输入次序不同，生成的邻接表也不同。因此，对于同一个图，**基于邻接矩阵的遍历所得到的DFS序列和BFS序列是唯一的**，**基于邻接表的遍历得到的DFS序列和BFS序列是不唯一的**。

- **DFS算法性能分析**

**（1）空间复杂度**

&emsp;&emsp;DFS是一个递归算法，需要借助一个递归工作栈，故其空间复杂度为$O(|V|)$。

**（2）时间复杂度**

&emsp;&emsp;遍历图的过程实际上是对每个顶点查找其邻接点的过程，其**耗费的时间取决于所用的存储结构**。

&emsp;&emsp;以**邻接矩阵**表示时，查找每个顶点的邻接点所需的时间为$O(|V|)$，故总的时间复杂度为$O(|V|^2)$

&emsp;&emsp;以**邻接表**表示时，查找所有顶点的邻接点所需的时间为$O(|E|)$，访问顶点所需的时间为$O(|V|)$，此时，总的时间复杂度为$O(|V|+|E|)$。

- **深度优先的生成树和生成森林**

&emsp;&emsp;与广度优先搜索一样，深度优先搜索也会产生一颗深度优先搜索树。当然，这是有条件的，即**对连通的DFS才能产生深度优先生成树**，**否则产生的将是深度优先森林**。与BFS类似，基于邻接表存储的优先生成树是不唯一的。

<img src="./数据结构/5.3.2-1.png" alt="5.3.2-1" style="zoom:80%;" />



### 5.4 图的应用

#### 5.4.1 最小生成树

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2012-8,2015-6</font>

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2017-42</font>

**（1）概念**

&emsp;&emsp;一个联通图的生成树是图的**极小联通子图**，它**包含图中所有的顶点，并且只含有尽可能少的边**。对于生成树而言，**砍去它的一条边，则会使生成树变成非连通图，若给它增加一条边，则会形成图中的一个环**。

&emsp;&emsp;对于一个带权的连通无向图$G=(V,E)$，生成树不同，每颗树的权也可能不同。设$R$为所有生成树的集合，若$T$为$R$中边的权值之和最小的那棵生成树，则$T$称为$G$的最小生成树(Minimun-Spanning-Tree,MST)。

**（2）最小生成树的性质**

- **最小生成树不是唯一的**，即最小生成树的树形不唯一，$R$中可能有多个最小生成树。**当$G$中的各边权互不相等时，$G$的最小生成树是唯一的**。

**【注】**：若无向连通$G$的边数比顶点数少1，即$G$本身就是一棵树时，则$G$的最小生成树就是它本身。

- **最小生成树的边的权值之和总是唯一的**，虽然最小生成树不唯一，但其对应边的权值之和总是唯一的，而且是最小的。
- **最小生成树的边数为顶点数减1**。
- 带权连通图的**任一环中包含的边的权值均不相同**时，其MST是唯一的。



##### 1. Prim算法

- **算法步骤**

<img src="./数据结构/5.4.1-2.png" alt="5.4.1-2" style="zoom:80%;" />

- **性能分析**

**时间复杂度**：$O(|V|^2)$

适用于求解边稠密的图的最小生成树。

- **例子**

<img src="./数据结构/5.4.1-1.png" alt="5.4.1-1" style="zoom:80%;" />



##### 2. Kruskal算法

- **算法步骤**

<img src="./数据结构/5.4.1-3.png" alt="5.4.1-3" style="zoom:80%;" />

- **性能分析**

时间复杂度：$O(|E|\log|E|)$

适合于边稀疏而顶点多的图。

- **例子**

<img src="./数据结构/5.4.1-4.png" alt="5.4.1-4" style="zoom:80%;" />



##### 3. Prim VS Kruskal

（1）使用Prim算法从不同顶点开始得到的最小生成树不一定相同

（2）使用Prim算法和Kruskal算法得到的最小生成树不一定相同



#### 5.4.2 最短路径

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2009-41</font>

&emsp;&emsp;带权有向图$G$的最短路径问题一般可分为两类：一是**单源最短路径**，即求图中某一顶点到其他顶点的最短路径，可通过经典的**Dijksta算法**求得；二是求**每对顶点间的最短路径**，可通过**Floyd-Warshall算法**求解。

##### 1. Dijkstra算法求单源最短路径

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2012-7,2016-8</font>

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2014-42</font>

&emsp;&emsp;该算法是设置一个集合$S$记录已求得的最短路径的顶点，可用一个数组s[ ]来实现，初始化为0，$s[v_i]=i$ 时表示$v_i$放入$S$，初始时把源点$v_0$放入S，此外，在构造的过程中还设置了两个辅助数组：

- **dist[]**：记录从源点$v_0$到其他各顶点当前的最短路径长度，dist[i]的初值为$arcs[v_0][i]$。
- **path[]**：path[i]表示从源点到顶点i之间的最短路径的前驱结点，在算法结束时，可根据其值追溯到源点$v_0$到顶点$v_i$的最短路径。

- **算法步骤**

&emsp;&emsp;假设从顶点0出发，即$v_0=0$，集合$S$最初只包含顶点0，邻接矩阵arcs表示带权有向图，$arc[i][j]$表示有向边$<i,j>$的权值，若不存在有向边$<i,j>$，则$arcs[i][j]$为$\infty$。

1）初始化：集合$S$初始为{0}，dist[]的初始值为$dist[i]=arcs[0][i]$，$i=1,2,\dots,n-1$。

2）从顶点集合$V-S$中选出$v_j$，满足$dist[j]=Min\{dist|v_i \in V-S\}$，$v_j$就是当前求得的一条从$v_o$出发的最短路径的终点，令$S=S \cup\{j\} $。

3）修改从$v_0$出发到集合$V-S$上任一顶点$v_k$可达的最短路径长度：

```python
if dist[j] + arcs[j][k] < dist[k]:
	dist[k] = dist[j] + arcs[j][k];
```

4）重复2)-3)操作n-1次，直到所有结点都包含在$S$中。

- **性能分析**

时间复杂度：$O(|V|^2) $

- **例子**

<img src="./数据结构/5.4.2-1.png" alt="5.4.2-1" style="zoom:80%;" />

<img src="./数据结构/5.4.2-2.png" alt="5.4.2-2" style="zoom:90%;" />

- **注意的问题**

&emsp;&emsp;**对于带负权值图Dijkstra是不适用的**。

<img src="./数据结构/5.4.2-3.png" alt="5.4.2-3" style="zoom:80%;" />



#### 5.4.3 拓扑排序

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2010-8,2012-6,2014-7,2016-7</font>

- **有向无环图**

若一个有向图中不存在环，则称为为有向无环图，简称为DAG图。

- **AOV网**

&emsp;&emsp;若用DAG图表示一个工程，其顶点表示活动，用有向边$<V_i,V_j>$表示活动$V_i$必须先于活动$V_j$进行的一种关系，则将这种有向图称为**顶点表示活动的网络**，记为AOV网。

&emsp;&emsp;在AOV网中，活动$V_i$是活动$V_J$的直接前驱，活动$V_j$是活动$V_i$的直接后继，任何活动不能以它自己作为自己的前驱或后继。

- **拓扑排序**

&emsp;&emsp;在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：

① 每个顶点出现且只出现一次。

② 若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径。

- **拓扑排序算法思想**

<img src="./数据结构/5.4.3-1.png" alt="5.4.3-1" style="zoom:90%;" />

例子：

<img src="./数据结构/5.4.3-2.png" alt="5.4.3-2" style="zoom:80%;" />

于是，得到拓扑排序后的结果为{1,2,4,3,5}

- **拓扑排序算法实现**

```c
bool TopologicalSort(Graph G) {
    InitStack(S);			//初始化堆栈，存储入度为0的顶点
    for(int i = 0;i < G.vexnum;i++)
        if(indegree(i) == 0)
            Push(S,i);		//将所有入度为0的顶点进栈
    int count = 0;
    while(!IsEmpty(S)) {
        Pop(S,i);			//弹出栈顶元素
        print[count++] = i; //输出顶点i
        for(p = G.vertices[i].firstarc;p;p = p->nextarc) {
            //将所有i指向的顶点入度减1.并且将入度减为0的顶点压入栈S
            v = p->adjvex;
            if(!(--indegree[v]))
                Push(S,v);	//入度为0，则入栈
        }
    }
    if(count < G.vexnum)
        return false;		//排序失败
    else
        return true;		//拓扑排序成功
}
```

- **算法性能分析**

&emsp;&emsp;由于输出每个顶点的同时，还要删除以它为起点的边，故拓扑排序的时间复杂度为$O(|E|+|V|)$。

- **用拓扑排序算法处理DAG图时，应该注意以下问题**：

<img src="./数据结构/5.4.3-3.png" alt="5.4.3-3" style="zoom:80%;" />

**【注】**：若用邻接矩阵存储有向图，矩阵中主对角线以下的元素均为零，则该拓扑序列存在，且可能不唯一。



#### 5.4.4 关键路径

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2013-9</font>

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2011-41</font>

- **AOE网**

&emsp;&emsp;在带权有向图中，以**顶点表示事件**，以**有向边表示活动**，以**边上的权值表示完成该活动的开销(如完成活动所需的时间)**，则称这种有向图用边表示活动的网络，简称为AOE网。

- **性质**

（1）只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；

（2）只有在进入某一顶点的各有向边所代表的活动都已结束时，该顶点所代表的时间才能发生；

- **几个概念**

（1）**源点**：AOE网中仅有一个入度为0的顶点，称为**开始顶点(源点)**。

（2）**汇点**：AOE网中仅存在一个出度为0的顶点，称为**结束顶点(汇点)**。

（3）**关键路径、关键活动**：从源点到汇点的所有路径中，具有最大路径的长度的路径称为关键路径，而把路径上的活动称为关键活动。

- **寻找关键活动**

1. **事件$v_k$的最早发生时间$v_e(k)$**

   从开始顶点$V$到$V_k$的最长路径长度。事件的最早发生时间决定了所有从$V_k$开始的活动能够开工的最早时间。可以用下面的递推公式计算：
   $$
   \begin{aligned}
   &v_e(源点)=0 \\
   &v_e(k)=\max \{v_e(j)+Weight(v_j,v_k)\}
   \end{aligned}
   $$
   $Weight(v_j,v_k)$表示$<v_j,v_k>$上的权值。

   **【注】**在计算$v_e(k)$时是按**从前往后**的顺序计算的。

2. **事件$v_k$的最迟发生时间$v_l(k)$**

   该时间是指在不推迟整个工程完成的前提下，即保证它所指向的事件$v_i$在$v_e(i)$时刻能够发生时，该事件最迟必须发生的时间。可用下面的递推公式来计算：
   $$
   \begin{aligned}
   &v_l(汇点)=v_e(汇点) \\
   &v_l(j)=\min \{v_l(k)-Weight(v_j,v_k)\}
   \end{aligned}
   $$
   **【注】**在计算$v_r(k)$时是**从后往前**计算的。

3. **活动$a_i$的最早开始时间$e(i)$**

   该时间是指该活动的起点所表示的事件最早发生的时间。若边$<v_k,v_j>$表示活动$a_i$，则有$e(i)=v_e(k)$

4. **活动$a_i$的最迟开始时间$ l(i)$**

   该时间是指该活动的终点所表示的最迟发生时间与该活动所需时间之差，若边$<v_k,v_j>$表示活动$a_i$，则有$l(i)=v_l(j)-Weight(v_k,v_j)$

5. **一个活动$a_i$的最迟开始时间$l(i)$和其最早开始时间$e(i)$的差额$d(i)=l(i)-e(i)$**

   它是指该活动完成的时间余量，即在不增加完成整个工程所需总时间的情况下，活动$a_i$可以拖延的时间。若一个活动的时间余量为0，则说明该活动必须如期完成，否则就会拖延完成整个工程的进度，所以称$l(i)-e(i)=0$即$l(i)=e(i)$的活动是**关键活动**。

- **求关键路径的算法步骤**

1）求AOE网络中所有**事件**的**最早发生时间**$v_e() $。

2）求AOE网络中所有**事件**的**最迟发生时间**$v_l()$。

3）求AOE网络中所有**活动**的**最早开始时间**$e()$。

4）求AOE网络中所有**活动**的**最迟开始时间**$l()$。

5）求AOE网络中所有活动的**差额**$d()$，找出所有$d()=0$的活动构成**关键路径**。

- **例子**

该例子得到的关键路径为$(v_1,v_3,v_4,v_6)$

![5.4.4-1](./数据结构/5.4.4-1.png)

**【注1】**关键路径上的所有活动都是关键活动，它是决定整个工程的关键因素，因此可加快关键活动来缩短整个工程的工期，但也不能任意缩短关键活动，因为一旦缩短到一定的程度，该关键活动就可能变成非关键活动。

**【注2】**网络中的关键路径并不唯一，且对于有几条关键路径的网，只提供一条关键活动的速度并不能缩短整个工程的工期，只有加快那些包含在所有关键路径上的关键活动才能达到缩短工期的目的。





## 第6章：查找



### 6.2 顺序查找和折半查找

#### 6.2.1 顺序查找

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2013-42</font>

&emsp;&emsp;顺序查找又称**线性查找**，主要用于在线性表中进行查找。顺序查找通常分为对**一般的无序线性表的顺序查找**和**对按关键字有序的顺序表查找**。

1. **一般线性表的顺序查找**

- **算法思想**

&emsp;&emsp;从线性表的一端开始，逐个检查关键字是否满足给定条件。若查找到某个元素的关键字满足给定条件，则查找成功，返回该元素在线性表中的位置。若已经查到表的另一端，但还没有找到符合给定条件的元素，则返回查找失败的信息。

- **算法实现**

```c
typedef struct{			//查找表的数据结构
    ElemType *elem		//元素存储空间基址，建表时按实际长度分配，0号单元留空
    int TableLen;		//表的长度
}SSTable;
int Search_Seq(SSTable ST,ElemType key) {
    //在顺序表ST中顺序查找关键字为key的元素。若找到则返回该元素在表中的位置
    ST.elem[0] = key;	//“哨兵”
    for(i = ST.TableLen;ST.elem[i] != key;i--);
    return i;
}
```

引入“哨兵”的目的是使得Search_Seq内的循环不必判断数组是否会越界，因为满足i == 0时，循环一定会跳出。

- $ASL_{成功}$与$ASL_{不成功}$

&emsp;&emsp;对于有$n$个元素的表，给定值key与表中第i个元素的关键字相等，即定位第i个元素时，需要进行n-i+1次关键字的比较，即$C_i=n-i+1$。查找成功时，顺序查找的平均长度为
$$
ASL_{成功}=\sum_{i=1}^nP_i(n-i+1)
$$
&emsp;&emsp;当每个元素的查找概率都相等时，即$P_i=1/n$时，有
$$
ASL_{成功}=\sum_{i=1}^nP_i(n-i+1) = \frac{n+1}{2}
$$
&emsp;&emsp;若查找不成功，与表中各关键字比较的次数明显是$n+1$次，从而顺序表查找不成功的平均查找长度为
$$
ASL_{不成功}=n+1
$$

- **优点 VS 缺点**
  - **优点**：对数据元素的存储没有要求，顺序存储或链式存储皆可。对表中记录的有序性也没有什么要求，无论记录是否按关键码有序。
  - **缺点**：当$n$比较大时，平均查找长度较大。



2. **有序表的顺序查找**

&emsp;&emsp;若在查找之前就已经知道表是关键字有序的，则查找失败时可以不用再比较到表的另一端就返回查找失败的信息，从而降低顺序表查找失败的平均长度。

<img src="./数据结构/6.2.1-1.png" alt="6.2.1-1" style="zoom:80%;" />

- **例子**

&emsp;&emsp;可以用所示的**判定树**来描述有序表的查找过程。树中的**圆形结点表示有序表中存在的元素**；树中的**矩形结点称为失败结点**，它描述的是那些不在表中的数据值集合。若查找到失败结点，则说明查找不成功。

**【注】**：**若有n个查找成功结点，则有n+1个失败结点**。

<img src="./数据结构/6.2.1-2.png" alt="6.2.1-2" style="zoom:80%;" />

- $AVL_{成功}$与$AVL_{不成功}$

&emsp;&emsp;在有序表的顺序查找中，查找成功的平均长度和一般线性表的顺序长度一样，即当每个元素的查找概率都相等时，即$P_i=1/n$时，有
$$
ASL_{成功}=\sum_{i=1}^nP_i(n-i+1) = \frac{n+1}{2}
$$
&emsp;&emsp;查找失败时，查找指针一定走到了某个失败结点。这些失败结点是我们虚构的空结点，实际上是不存在的，所以**到达失败结点时所查找的长度等于它上面一个圆结点所在的层数**。查找不成功的平均查找长度在查找概率相等的情形下为
$$
ASL_{不成功}=\sum_{j=1}^n q_j(l_j-1)= \frac{1+2+\dots +n+n}{n+1} =\frac{n}{2}+\frac{n}{n+1}
$$
其中，$q_j$是到达失败点的概率，在相等查找概率的情况下为$1/(n+1)$；$l_j$是第$j$个失败结点所在的层数。



#### 6.2.2 折半查找

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2010-9,2015-7,2016-9,2017-8[难]</font>

&emsp;&emsp;折半查找又称为**二分查找**，它适用于**有序的顺序表**。

- **算法思想**

&emsp;&emsp;给定值key与表中间位置元素的关键字比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分(例如，在查找表升序时，若给定值key大于中间元素的关键字，则所查找的元素只能在后半部分)。然后再缩小范围内继续进行同样的查找，如此重复，直到找到为止，否则查找不成功，返回查找失败。

- **算法实现**

```c++
int Binary_Search(SeqList L,ElemType key) {
    //在有序表L中查找关键字为key的元素，若存在则返回其位置，不存在则返回-1
    int low = 0,high = L.TabelLen-1,mid;
    while(low <= high) {
        mid = (low+high)/2;		//取中间位置
        if(L.elem[mid] == key)	//查找成功返回所在位置
            return mid;
        else if(L.elem[mid] > key)
            high = mid - 1;		//从前半部分继续查找
        else
            low = mid + 1;
    }
    return -1;					//查找失败
}
```

- **例子**

&emsp;&emsp;已知11个元素的有序表{7,10,13,16,19,29,32,37,41,43}，折半查找的过程可以用图示的二叉树来描述，称为**判定树**。树中每个**圆形结点表示一个记录**，结点中的值为该记录的关键字；树中最下面的叶结点都是**矩形，它表示查找不成功的情况**。

&emsp;&emsp;**查找成功**：查找长度为从根结点到目的结点的路径上的结点数。

&emsp;&emsp;**查找失败**：查找长度为从根结点到对应失败结点的父结点的路径上的结点数

**【注1】**：**每个结点值大于其左子结点值，小于其右子结点值**。

**【注2】**：若有序序列有n个元素，则对应的判定树有n个圆形的非叶结点和n+1个方形的叶结点。

**【注3】**：折半查找的判断树是一个**二叉排序树**。

<img src="./数据结构/6.2.2-1.png" alt="6.2.2-1" style="zoom:90%;" />

- $AVL_{成功}$与$AVL_{不成功}$

&emsp;&emsp;由上述分析可知，用折半查找到给定值的比较次数最多不超过树的高度。在等概率查找时，查找成功的平均查找长度为
$$
\begin{aligned}
ASL_{成功} &=\frac{1}{n}\sum_{i=1}^nl_i=\frac{1}{n}(1\times 1+ 2\times2+\dots+h\times2^{h-1}) \\
&= \frac{n+1}{n}\log_2(n+1)-1 \approx\log_2(n+1) -1
\end{aligned}
$$
其中，$h$是树的高度，并且元素个数为$n$时树的高度$h=\lceil \log_2(n+1)\rceil$。所以折半查找的时间复杂度为$O(\log_2 n)$，平均情况下比顺序查找的效率高。 

- **特点**

&emsp;&emsp;因为折半查找需要方便地定位查找区域，所以适合折半查找的存储结构必须具有随机存取特性。因此该查找算法仅**适合线性表的顺序存储结构，不适合于链式存储结构**。



### 6.3 B树与B+树

#### 6.3.1 B树及其基本操作

1. **B树的定义**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-8,2013-10,2014-9</font>

&emsp;&emsp;B树，又称**多路平衡查找树**，B树中所有结点的孩子结点数的最大值称为B树的阶，通常用$m$表示。一颗$m$阶B树或为空树，或为满足如下特性的$m$阶树：

1）树中每个结点**至多有$m$颗子树**(即至多含有**$m-1$个关键字**)

2）若**根结点**不是终端结点，则**至少有两颗子树**

3）**除根结点外**的所有**非叶子结点**至少有$\biggl\lceil m/2 \biggr\rceil$颗子树(即至少含有$\biggl\lceil m/2 \biggr\rceil -1$个关键字)。

4）所有非叶子结点的结构如下：

![6.3.1-1](./数据结构/6.3.1-1.png)

其中，$K_i(i=1,2,\dots,n)$为结点的关键字，且满足$K_1 < K_2 < \dots <K_n$，

$P_i(i=1,2,\dots,n)$为指向子树中所有结点的关键字均大于$K_i$。

结点中关键字个数$n$满足$\biggl\lceil m/2 \biggr\rceil -1 \le n \le m-1 $

5）所有叶子结点都在同一层上，并且不带信息。

![6.3.1-2](./数据结构/6.3.1-2.png)



4. **B树的删除**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2012-9</font>

- 当**删除的关键字k不在终端结点(最底层非叶子结点)中**时，有下列几种情况：

<img src="./数据结构/6.3.1-3.png" alt="6.3.1-3" style="zoom:80%;" />

- 当**删除的关键字k在终端结点(最底层非叶子结点)中**时，有下列几种情况：

<img src="./数据结构/6.3.1-4.png" alt="6.3.1-4" style="zoom:80%;" />

<img src="./数据结构/6.3.1-5.png" alt="6.3.1-5" style="zoom:81%;" />





#### 6.3.2 B+树的基本概念

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2017-9</font>

一颗$m$阶的B+树需要满足下列条件

1）每个分支节点最多有$m$颗子树

2）非叶子结点至少两颗子树，其它每个结点至少有$\biggl\lceil m/2 \biggr\rceil$颗子树

3）结点的子树个数 = 关键字个数

4）**所有叶结点包含全部关键字**及指向相应记录的指针，叶结点中将关键字按大小排列，并且相邻叶结点按大小顺序相互链接起来。

 5）所有分结点(可视为索引结点)中仅包含它的各个子结点(即下一级的索引块)中关键字的最大值及其指向其子结点的指针。

![6.3.2-1](./数据结构/6.3.2-1.png)

通常在B+树中有两个头指针：一个指向根节点，另一个指向关键字最小的叶子结点。即可以对B+树进行两种查找运算：(1) **从最小关键字开始的顺序查找**； （2）**从根结点开始的多路查找**。

- $m$**阶的B+树与$m$阶的B树的主要差别**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2016-10</font>

（1）在B+树中，具有$n$个关键字的结点只有$n$棵子树，即每个关键字对应一颗子树；而在B树中，具有$n$个关键字的结点含有$n+1$课子树。

（2）在B+树中，每个结点(非根内部结点)的关键字个数$n$的范围是$\biggl\lceil m/2 \biggr\rceil  \le n \le m $；而在B树中，具有每个结点(非根内部结点)的关键字个数$n$的范围是$\biggl\lceil m/2 \biggr\rceil -1 \le n \le m-1 $。(根结点是：$1\le n \le m-1$)

（3）在B+树中，叶结点包含信息，所有非叶子结点仅索引作用，非叶子结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。

（4）在B+树中，叶结点包含了全部关键字，即在非叶子结点中出现的关键字也会出现在叶结点中；而在B树中，叶结点包含的关键字和其它结点包含的关键字是不重复的。

（5）B+树支持顺序查找，而B树不支持顺序查找，只支持多路查找。

**【注】**B+树适合实际应用中的**操作系统的文件索引**和**数据库索引**。



### 6.4 散列表

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2010-41</font>

#### 6.4.1 散列表的基本概念

1. **散列函数**

&emsp;&emsp;一个把查找表中的关键字映射成该关键字对应的地址的函数，记为
$$
Hash(key) = Addr
$$
&emsp;&emsp;散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为**冲突**，这些发生碰撞的不同关键字称为**同义词**。

2. **散列表**

&emsp;&emsp;根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。

#### 6.4.2 散列函数的构造方法

1. **直接定址法**

$$
H(key)=a \times key +b
$$

其中，$a$和$b$是常数。这种方法计算最简单，且不会产生冲突。它适合关键字的分布基本连续的情况，若关键字分布不连续，空位比较多，则会造成存储空间的浪费。

2. **除留余数法**

&emsp;&emsp;假定散列表长为$m$，取一个不大于$m$但接近或等于$m$的质数$p$，散列函数为
$$
H(key)=key \% p
$$
除留余数法的关键是选好$p$，使得每个关键字通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减少冲突的可能性。

**【注】**以上是经常用到的两种散列函数，一般题目会给出具体的散列函数。

#### 6.4.3 处理冲突的方法

1. **开放地址法**

&emsp;&emsp;所谓开放地址法，是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式为
$$
H_i = (H(key)+d_i)\% m
$$
其中，$i=0,1,2,\dots,k(k \leq m-1)$，$m$表示散列表表长，$d_i$为增量序列。

​	**1）线性探测法**。当$d_i=0,1,\dots,m-1$时，称为线性探测法。会造成大量元素**“聚集”(或堆积)**现象，大大降低了查找效率。、

​	**2）平方探测法**。当$d_i=0^2,1^2,-1^2,\dots,k^2,-k^2$时，称为平方探测法，其中$k \leq m/2$，散列表长度$m$必须是一个可以表示成$4k+3$的素数，又称为**二次探测法**。它是一个比较好的处理冲突的方法，**可以避免“堆积”问题**，它的缺点是**不能探测散列表上的所有单元，但至少能探测到一半单元**。

2. **拉链法(链接法)**

&emsp;&emsp;对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个散列表由其散列地址唯一标识。

> 例如，关键字序列为{19,14,23,01,68,20,84,27,55,11.10,79}，散列函数H(key) = key%3，用拉链法处理冲突，建立的表如图所示

![6.4.3-1](./数据结构/6.4.3-1.png)

#### 6.4.4 散列查找及性能分析

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-9,2014-8</font>

&emsp;&emsp;散列表的查找过程与构造散列表的过程基本一致。对于一个给定的关键字key，根据散列函数可以计算出其散列地址，执行步骤如下：

> 初始化：Addr=Hash(key)
>
> （1）检查表中地址为Addr的位置上是否有记录，若无记录，返回失败；若有标记，比较它与key的值，若相等，则返回查找成功标志，否则执行（2）
>
> （2）用给定的处理冲突方法计算“下一个散列地址”，并把Addr置为此地址，转入（1）

- 散列表的查找效率取决于三个因素：**散列函数**、**处理冲突的方法**和**装载因子**。

- **装载因子**$\alpha$

$$
\alpha = \frac{表中的记录n}{散列表的长度m}
$$

散列表的**平均查找长度**取决于散列表的装载因子$\alpha$，而不直接依赖于$n$或$m$，直观地看，$\alpha$越大，表示装载的记录越“满”，发生冲突的可能性越大，反之发生的冲突可能性越小。

**【注】**产生堆积现象，即产生了冲突，它对存储效率、散列函数和装载因子均不会有影响，而平均查找长度会因为堆积现象而增大。



### 6.5 串

#### 6.5.1 串的定义

&emsp;&emsp;串(string)是由零个或多个字符组成的有限序列，一般记为
$$
S = "a_1a_2\dots a_n"(n \ge0)
$$
其中，$S$是串名，双引号括起来的字符序列是串的值；$a_i$可以是字母、数字或其它字符；串中的字符个数$n$称为串的长度。$n=0$时的串称为空串。

&emsp;&emsp;串中的任意连续的字符组成的子序列称为该串的**子串**，包含字串的串相应地称为主串。通常称字符在序列中的序号称为该字符在串中的位置。**字串在主串中的位置以字串的第一个字符在主串中的位置来表示**。当两个串的长度相等且每个对应位置的字符都相等时，称这两个串是相等的。

&emsp;&emsp;需要注意的是，由一个或多个空格(空格是特殊字符)组成的串称为空格串**(空格串不是空串)**，其长度为串中空格字符的个数。





#### 6.5.4 串的模式匹配

&emsp;&emsp;**子串的定位操作**通常称为串的模式匹配，它要求的是字串(常称为模式串)在主串中的位置。上节中曾利用串的其他基本操作给出了定位操作的一种算法，这里采用**定长顺序存储结构**，写出一种不依赖于其他串操作的匹配算法。

- **算法思想**

&emsp;&emsp;分别用计数指针$i$和$j$指示主串$S$和模式串$T$中正当比较的字符位置。从主串$S$的第pos个字符起，与模式串的第一个字符比较，若相等，则继续逐个比较后序字符；否则从主串的下一个字符起，重新和模式的字符比较；依次类推，直至模式$T$中的每个字符依次和主串$S$中的一个连续的字符序列相等，则匹配成功，函数值为与模式$T$中第一个字符相等的字符在主串$S$中的序号，否则称匹配不成功，函数值为零。

- **算法实现**

```c
int Index(SString S,SString T,int pos){
    int i = pos,j = 1;
    while(i<=S.length && j<=T.length){
        if(S.ch[i]==T.ch[j]){		//继续比较后继字符
            ++i;
            ++j;
        }else{
            i=i-j+2;				//指针后退重新开始匹配
            j=1;
        }
    }
    if(j>T.length)	return i-T.length;
    else
        return 0;
}
```

- **算法性能分析**

最坏的时间复杂度为：$O(mn)$

- **例子**

<img src="./数据结构/6.5.4-1.png" alt="6.4.3-1" style="zoom:80%;" />





#### 6.5.5 改进的模式匹配算法——KMP算法



1. **字符串的前缀、后缀和部分匹配**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2014-6,2015-8</font>

以'ababa'为例进行说明：

- 'a'的前缀和后缀为空集，最长相等前后长度为0
- ‘ab’的前缀为{a}，后缀为{b}，{a}&cap;{b}=&empty;，最长相等前后长缀为0。
- 'aba'的前缀为{a,ab}，后缀为{a,ba}，{a,ab}&cap;{a,ba}={a}，最长相等前后长缀为1。
- 'abab'的前缀{a,ab.aba,abab}&cap;后缀{b,ab,bab}={ab}，最长相等前后缀长度为2。
- 'ababa'的前缀{a,ab,aba,abab}&cap;后缀{a,ba,aba,baba}={a,aba}，公共元素有2个，最长相等前后缀为3。

故**字符串'ababa'的部分匹配为00123**。



## 第7章：排序

### 7.2 插入排序

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-10,2012-11</font>

#### 7.2.1 直接插入排序

- **算法思想**

![7-1](./数据结构/7-1.png)

要将元素$L[i]$插入到已有序的子序列$L[1\dots i-1]$中，需要执行以下操作：

​	1）查找出$L[i]$在$L[1\dots i-1]$中的插入位置$k$

​	2）将$L[k\dots i-1]$中的所有元素全部后移一个位置

​	3）将$L[i]$复制到$L[k] $

- **算法实现**

```c++
void InsertSort(ElemType A[],int n) {
    int i,j;
    for(i = 2;i <= n;i++) { //依次将A[2]-A[n]插入到前面已排序序列
        if(A[i].key < A[i-1].key) { //若A[i]的关键码小于前驱，需要将A[i]插入有序表
            A[0] = A[i];	//复制为哨兵，A[0]不存放元素
            for(j = i-1;A[0].key < A[j].key;--j) //从后往前查找待插入位置
                A[j+1] = A[j]	//向后挪位
            A[j+1] = A[0] 		//复制到插入位置
        }
    }   
}
```

- **例子**

![7-2](./数据结构/7-2.jpg)

- **性能分析**

**空间效率**：仅使用了常数个辅助单元，因而空间复杂度为$O(1)$。

**时间效率**：$O(n^2 )$

（1）**比较次数和移动次数取决于待排序表的初始状态**。

（2）**最好的情况**是**表中元素已经有序**，**最坏的情况**是**表中的元素是逆序**。

（3）**稳定性**：直接插入排序**是**稳定的算法

（4）**适用性**：适用于**顺序存储和链式存储**的线性表。



#### 7.2.2 折半插入排序

&emsp;&emsp;从前面的直接插入排序算法中，不难看出每趟插入的过程中，都进行了两项工作：**(1)从前面的子表中查找出待插入元素应该被插入的位置**；**(2)给插入位置腾出空间，将待插入元素复制到表中的插入位置**。该算法中，总是**边比较边移动元素**。

&emsp;&emsp;可以分离比较和移动操作分离，即先折半查找出元素的待插入位置，然后统一地移动插入位置之后的所有元素。

```c++
void InsertSort(ElemType A[],int n) {
    int i,j,low,high,mid;
    for(i = 2;i < n;i++) {  	//依次将A[2]~A[n]插入到前面已排序的序列
     	A[0] = A[i]   			//将A[i]暂存到A[0]
        low = 1;hight = i-1;	//设置折半查找范围
        while(low<=high) {		//折半查找(默认递增有序)
            mid = (low+high)/2; //取中间点
            if(A[mid].key > A[0].key)	//查找右半子表
                high = mid - 1;			
           	else						//查找左半子表
                low = mid + 1;
        }
        for(j = i-1;j >= high+1;--j)
            A[j+1] = A[j];		//统一元素往后移动
        A[high+1] = A[0];		//插入操作
    }
}
```

- **性能分析**

**比较次数和移动次数与表的初始状态无关**。



#### 7.2.3 希尔排序

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2014-10,2015-11</font>

&emsp;&emsp;直接插入排序算法适用于基本有序的排序表和数据量不大的排序表。希尔排序可以减少排序量。

- **算法思想**

&emsp;&emsp;先将排序表分割成若干形如$L[i,i+d,i+2d,...,i+kd]$的"特殊"子表，分别进行**直接插入算法**，当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。

- **算法过程**

&emsp;&emsp;先取一个小于n的步长$d_1$，把表中的全部记录分成d组，所有距离为d的倍数的记录放在同一组中，在各组中进行直接插入排序；

&emsp;&emsp;然后取第二个步长$d_2 < d_1$，重复上述过程，直到所取的$d_i=1$，即所有的记录都放在同一组，再进行直接插入排序，由于此时已经具有较好的局部有序性，故很快得到最终结果。

&emsp;&emsp;目前，尚未求得一个最好的增量排序，希尔提出的方法是$d_1 = n/2,...,d_{i+1}=d_i/2$，并且最后一个增量等于1。

- **算法实现**

```c
void ShellSort(ElemType A[],int n){
    //对顺序排序表做希尔插入排序，本算法和直接插入排序相比，做了以下修改：
    //1.前后记录位置的增量是dk，不是1
    //2.A[0]只是暂存单元，不是哨兵，当j<=0时，插入位置已到
    for(dk = n/2;dk >= 1;dk = dk/2){	//步长变化
        for(i=dk+1;i<=n;++i)
            if(A[i].key<A[i-dk].key){	//需将A[i]插入有序增量子表
                A[0] = A[i];
                for(j=i-dk;j>0&&A[0].key<A[j].key;j-=dk)
                    A[j+dk] = A[j];		//记录后移，查找插入的位置
                A[j+dk] = A[0]
            }
    }
}
```

- **性能分析**

**空间效率：**使用常数个辅助单元，因而空间复杂度为$O(1)$

**时间效率：**希尔排序的时间复杂度依赖于增量序列的函数。当n在某个特定范围时，希尔排序的时间复杂度为$O(n^{1.3})$。最坏的情况下希尔排序的时间复杂度为$O(n^2)$

**稳定性：**希尔排序**不是**稳定的排序算法

**适应性：**希尔排序仅适用于线性表为**顺序存储**的情况



### 7.3 交换排序

&emsp;&emsp;所谓交换，是指根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。

#### 7.3.1 冒泡排序

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2010-11</font>

- **算法思想**

&emsp;&emsp;假设待排序表长为n，从后往前(或从前往后)两两比较相邻元素的值，若为逆序(即A[i-1] > A[i])，则交换它们，直到序列比较完，这是一趟冒泡，结果是将最小的元素交换到待排序序列的第一个位置。下一趟冒泡时，前一趟确定的最小元素不再参与比较，待排序列减少一个元素，**每趟冒泡的结果是把序列中的最小元素放到序列最终位置**。这样**最多做n-1趟冒泡就能把所有元素排好序**。

- **算法实现**

```c++
void BubbleSort(ElemType A[],int n) {
    //用冒泡排序法将序列A中的元素按从小到大排序
    for(i = 0;i < n-1;i++) {
        flag = false;			//表示本趟冒泡是否发生交换的标志
        for(j = n-1;j > i;j--){	//一趟冒泡过程
        	if(A[j-1].key > A[j].key) {		//若为逆序
                swap(A[j-1],A[j]);			//交换
                flag = true;
        }
        if(flag == false)
            return;				//本趟遍历后没有发生交换，说明表已经有序
    }
}
```

- **性能分析**

**空间效率**：仅适用了常用个赋值单元，因而空间复杂度为$O(1)$。

**时间效率**：

（1）**最好的情况**：初始序列**有序**，只**需要一趟冒泡**，flag依旧为false，直接return，比较次数为n-1，移动次数为0，因此时间复杂度为$O(n)$。

（2）**最坏的情况**：初始序列逆序，需要进行n-1趟冒泡，第$i$趟冒泡要进行$n-i$次关键字的比较，而且每次比较都需**移动元素3次(swap操作)**来交换元素位置。这种情况下
$$
比较次数=\sum_{i=1}^{n-1}(n-i)=\frac{n(n-1)}{2},\quad 移动次数=\sum_{i=1}^{n-1}3(n-i)=\frac{3n(n-1)}{2}
$$
因此，最坏情况下的时间为$O(n^2)$，其平均时间复杂度也为$O(n^2)$。

**稳定性**：冒泡排序是一个稳定的排序算法。



#### 7.3.2 快速排序

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2010-10,2011-10,2014-11</font>

- **算法思想**

&emsp;&emsp;快速排序是对冒泡排序的一种改进，其基本思想是基于**分治法**的：在待排序的$L[1\dots n]$中任意取一个元素pivot作为基准，通过一趟排序将待排序表划分为独立的两部分$L[1\dots k-1]$和$L[k+1\dots n]$，使得$L[1\dots k-1]$中的所有元素**小于pivot**，$L[k+1\dots n]$中的所有元素**大于等于pivot**，则pivot放在最终的位置$L[k]$上，这个过程称为一次快速排序。然后分别递归对两个子表重复上述过程，直到每部分内只有一个元素为止，即**所有元素放在了其最终的位置上**。

- **算法实现**

&emsp;&emsp;假设划分算法已知，记为Partition()，返回的是上述的k，注意到$L[k]$已在最终的位置，因此可以先对表进行划分，而然后对两个表调用同样的排序操作。具体的算法如下：

```c++
void QuickSort(ElemType A[],int low,int high) {
    if(low < high) {		//递归跳出的条件
        //Partition()就是划分操作，将表A[low...high]划分为满足上述条件的两个子表
        int pivotpos = Partition(A,low,high);	//划分
        QuickSort(A,low,pivotpos-1);	//依次对两个子表进行递归操作
        QuickSort(A,pivotpos+1，high);
    }
}
```

&emsp;&emsp;从上述的代码可以发现快速排序算法的**关键在于划分操作**，同时快速排序算法的性能也主要取决于划分操作的好坏。Partition的实现如下：

```c++
int Partition(ElemType A[],int low,int high) {
	ElemType pivot = A[low];	//将当前表中的第一个元素设为枢纽值，对表进行划分
	while(low < high) {			//循环跳出条件
        //从右端往左移动直至找到第一个比枢纽值小的数
		while(low<high && A[high]>=pivot)	--high;
		A[low] = A[high];		//将比枢纽值小的元素移动到左端
        //从左端往右移动直至找到第一个比枢纽值大的数
		while(low<high && A[low]<=pivot)	++low;
		A[high] = A[low];
	}
	A[low] = pivot;				//枢纽元素存放到最终的位置
	return low;					//返回枢纽的最终位置
}
```

- **Partition例子**

<img src="./数据结构/7.3.2-1.png" alt="7.3.2-1" style="zoom:80%;" />



- **性能分析**

**空间效率**：借助一个递归工作栈

（1）**最好的情况**：栈容量与递归调用的最大深度一致，为$\lceil \log_2(n+1)\rceil$

（2）**最坏的情况**：需进行n-1次递归调用，为$O(n)$

（3）**平均情况**：$O(\log_2 n)$

**时间效率**：与是否划分对称有关，即与具体使用的划分算法有关

（1）**最坏的情况**：两个分区分别包含**n-1个元素和0个元素**时，这对应于**初始排序表基本有序或基本无序**。时间复杂度为$O(n^2)$。

（2）**最好的情况**：即Partition()可能做到最平衡的划分，时间复杂度为$O(n\log_2 n)$。

（3）**平均情况**：与最佳运行时间很接近。

**稳定性**：快速排序**不是**一个稳定的算法。

**【注1】**快速排序是**所有内部排序算法中平均性能最优的排序算法**。

**【注2】**在快速排序中，并不产生有序子序列，但每趟排序后会将一个元素(基准元素)放到其最终的位置上。



### 7.4 选择排序

#### 7.4.1 简单选择排序

- **算法思想**

&emsp;&emsp;假设排序表为$L[1\dots n]$，第$i$趟排序即从$L[i\dots n]$中选择关键字最小的元素与$L[i]$交换，每一趟排序可以确定一个元素的最终位置，这样经过$n-1$趟就可以使得整个排序有序。

- **算法实现**

```c
void SelectSort(ElemType A[],int n){
    //对表A做简单选择排序，A[]从0开始存放元素
    for(i=0;i<n-1;i++){			//一共进行n-1趟
        min = i;				//记录最小元素位置
        for(j=i+1;j<n;j++)		//在A[i...n-1]中选择最小的元素
            if(A[j]<A[min])	min=j;		//更新最小元素位置
        if(min!=i)	swap(A[i],A[min]);	//与第i个位置交换
    }
}
```

- **算法性能分析**

**空间复杂度**：仅使用常数个辅助单元，故空间效率为$O(1)$。

**时间复杂度**：在简单选择排序过程中，元素移动的操作次数很少，不会超过$3(n-1)$次，最好的情况是移动0次，此时对应的表已经有序；但**元素间的比较次数与序列的初始状态无关**，始终是$n(n-1)/2$次，所以时间复杂度始终是$O(n^2)$。

**稳定性**：简单排序算法**不是**稳定的排序算法。



#### 7.4.2 堆排序

- **定义**

&emsp;&emsp;$n$个关键字序列$L[1\dots n]$称为堆，当且仅当该序列满足：

① $L[i] \le L[2i]$且$L[i] \le L[2i+1]$	**小根堆**	或

② $L[i] \ge L[2i]$且$L[i] \ge L[2i+1]$	**大根堆**

&emsp;&emsp;在大根堆中，最大元素放在根结点中，且对其任一非根结点，它的值小于等于其双亲结点值，小根堆恰好相反。**堆经常被用来实现优先级队列**。

<img src="./数据结构/7.4.2-1.png" alt="7.4.2-1" style="zoom:90%;" />

- **堆初始化**

&emsp;&emsp;对初始序列建堆，是一个反复筛选的过程。$n$个结点的完全二叉树，最后一个结点是第$\lfloor n/2 \rfloor$个结点的孩子。对$\lfloor n/2 \rfloor $个结点为根的子树筛选，使该子树成为堆。之后依次对各结点($\lfloor n/2 \rfloor $~1)为根的子树进行筛选，看该结点是否大于其左右子结点的值(大根堆为例)，若不大于，则将左右子结点中的较大值与之交换，交换后可能会破坏下一级的堆，于是继续采用上述方法结构下一级的堆，直到以该结点为根的子树成堆为止。

<img src="./数据结构/7.4.2-2.png" alt="7.4.2-2" style="zoom:80%;" />



下面是建立大根堆的算法：

```c
void BuildMaxHeap(ElemType A[],int len){
    for(int i = len/2;i > 0;i--)	//从i=[n/2]~1,反复调整堆
        AdjustDown(A,i,len);
}
void AdjustDown(ElemType A[],int k,int len){
    //函数AdjustDown将元素k向下进行调整
    A[0] = A[k];				//A[0]暂存
    for(i = 2*k;i <= len;i*=2){ //沿key较大的子结点向下筛选
        if(i<len && A[i]<A[i+1])
            i++;				//取key较大的子结点下标
        if(A[0] >= A[i]) break; //筛选结束
        else{
            A[k] = A[i];		//将A[i]调整到双亲结点上
               k = i;			//修改k值，以便继续向下筛选
        }
    }
    A[k] = A[0];				//被筛选的结点的值放在最终的位置
}
```

**时间复杂度**：$O(n) $



- **堆排序**

&emsp;&emsp;首先将存放在$L[1\dots n]$中的n个元素建成初始堆，由于堆本身的特点(以大根堆为例)。堆顶元素就是最大值。输出堆顶元素后，通常**将堆底元素送入堆顶**，此时不满足大根堆的性质，将堆顶元素向下调整使其继续保持大根堆的性质，再输出堆顶元素。如此重复，直到堆中仅剩下一个元素为止。

```c
void HeapSort(ElemType A[],int len){
    BuildMaxHeap(A,len);		//初始化建堆
    for(i=len;i>1;i--){			//n-1趟的交换和建堆过程
        Swap(A[i],A[1]);		//输出堆顶元素(和堆底元素交换)
        AdjustDown(A,1,i-1);	//整理，把剩余的i-1个元素整理成堆
    }
}
```

- **堆的删除**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2015-10</font>

&emsp;&emsp;由于堆顶元素或为最大值或最小值，删除堆顶元素时，先**将堆的最后一个元素与堆顶交换**，由此堆的性质被破坏，需要此时的根结点进行向下调整操作。

- **堆的插入**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-9,2011-11</font>

&emsp;&emsp;对堆进行插入操作时，先将新结点放在堆的末端，再对这个新结点执行向上调整操作，大根堆的插入过程如图：

<img src="./数据结构/7.4.2-3.png" alt="7.4.2-3" style="zoom:80%;" />

下面是向上调整堆的算法：

```c
void AdjustUp(ElemType A[],int k){
	//参数k为向上调整的结点，也为堆的元素个数
	A[0] = A[k];
    int i = k/2;	//若结点值大于双亲结点，则将双亲结点向下调，并继续向上比较
    while(i>0 && A[i]<A[0]){ //循环跳出条件 
        A[k] = A[i];		 //双亲结点下调
        k = i;
        i = k/2;			 //继续向上比较
    }
    A[k] = A[0];			 //复制到最终位置
}
```

- **性能分析**

**空间效率**：仅使用了常数个辅助单元，故空间复杂度为$O(1)$

**时间效率**：建堆的时间$O(n)$，之后n-1次向下调整操作，每次调整的时间复杂度为$O(h)$，故在最好、最坏和平均情况下，堆排序的时间复杂度为$O(n\log_2 n)$。

**稳定性**：不是一个稳定的排序算法。



### 7.5 归并排序和基数排序

#### 7.5.1 归并排序

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2016-11</font>

&emsp;&emsp;归并排序将两个或两个以上的有序表组合成一个新的有序表。假定待排序表含有$n$个记录，则可以将其视为$n$个有序子表，每个子表长度为1，然后两两归并，得到$\lceil n/2 \rceil$个长度为2或1的有序表；再两两归并......如此重复，直到合并成一个长度为$n$的有序表为止，这种排序的方法称为**2路归并排序**。

**【注】**外部排序指待排序的文件较大，内存一次性放不下，需存放在外部介质中。**外部排序通常采用归并算法**。

<img src="./数据结构/7.5.1-1.png" alt="7.5.1-1" style="zoom:80%;" />

- **算法实现**

&emsp;&emsp;Merge()的功能是将前后相邻的两个有序表归并为一个有序表。设两段有序表A[low...mid]、A[mid+1...high]存放在同一顺序表中的相邻位置，先将它们重复复制到辅助数组B中。每次从对应B中的两个段取出一个记录进行关键字比较，将较小者放入A中，当数组B中有一段的下标超出其对应的表长(即该段的所有元素已完全复制到A)时，将另一段中的剩余部分直接复制到A中。算法如下：

```c
ElemType *B = (ElemType *)malloc(n+1)*sizeof(ElemType);			//辅助数组B
void Merge(ElemType A[],int low,int mid,int high){
    //表A的两端A[low...mid]和A[mid+1...high]各自有序，将它们合并成一个有序表
    for(int k=low;k<=high;k++)
        B[k]=A[k];				//将A中所有的元素复制到B中
    for(i=low,j=mid+1,k=i;i<=mid&&j<=high;k++) {
        if(B[i]<=B[j])			//比较B的左右两端中的元素
            A[k]=B[i++];
    	else
            A[k]=B[j++]
    }
    while(i<=mid)	A[k++]=B[i++];	//若第一个表未检测完
    while(j<=high)	A[k++]=B[j++];	//若第二个表未检测完
}
```

整个归并排序需要进行$\lceil \log_2 n \rceil$趟。

&emsp;&emsp;递归形式的2路归并排序算法是基于分治的，其过程如下：

**（1）分解**：将含有$n$个元素待排序表分解成各含有$n/2$个元素的子表，采用2路归并排序算法对两个子表递归地进行排序。

**（2）合并**：合并两个已排序的子表得到排序结果。

```c
void MergeSort(ElemType A[],int low,int high){
    if(low<high){
        int mid = (low+high)/2;		//从中间划分出两个子序列
        MergeSort(A,low,mid);		//对左侧子序列进行递归排序
        MergeSort(A,mid+1,high);	//对右侧子序列进行递归排序
        Merge(A,low,mid,high);		//归并
    }
}
```

- **性能分析**

**空间效率：**Merge()操作中，辅助空间刚好占用$n$个单元，所以归并排序的空间复杂度为$O(n)$。

**时间效率：**每趟归并排序的时间复杂度为$O(n)$，共需进行$\lceil \log_2 n \rceil$趟归并，所以算法的时间复杂度为$O(n \log_2 n )$。如果是k路归并那么时间复杂度为$O(n \log_k n)$。

**稳定性**：二路归并排序**是**一个稳定的算法。



#### 7.5.2 基数排序

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2013-11</font>

&emsp;&emsp;基数排序基于**多关键字排序思想(即基于关键字各位的大小进行排序)**，借助**“分配”**和**“收集”**两种操作对单逻辑关键字进行排序。基数排序又分为**最高位优先(MSD)排序**和**最低位优先(LSD)排序**。

- **以$r$为基数的最低位优先基数排序的过程**

&emsp;&emsp;假设线性表由结点序列$a_0,a_1,\dots,a_{n-1}$构成，每个结点$a_j$的关键字由$d$元组($k_j^{d-1},k_j^{d-2},\dots,k_j^1,k_j^0$)组成，其中$0\le k_j^i \le r-1(0\le j \le n-1,0 \le i \le d-1)$。在排序的过程中，使用$r$个队列$Q_0,Q_1,\dots,Q_{r-1}$，排序过程如下：

<img src="./数据结构/7.5.2-1.png" alt="7.5.2-1" style="zoom:80%;" />

- **例子**

<img src="./数据结构/7.5.2-2.png" alt="7.5.2-2" style="zoom:80%;" />

- **性能分析**

**空间效率：**一趟排序需要的辅助存储空间为$r$($r$个队列)，但以后的排序会重复使用这些队列，所以基数排序的空间复杂度为$O(r)$。

**时间效率：**基数排序需要进行$d$趟分配和收集，一趟分配需要$O(n)$，一趟收集需要$O(r)$，所以基数排序的时间复杂度为$O(d(n+r))$，**它与序列初始状态无关**。

**稳定性：**基数排序是一个**稳定的**排序算法。



### 7.6 各种内部排序算法的比较及应用

#### 7.6.1 内部排序算法的比较

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2012-10,2015-9,2017-10/11</font>

- **稳定的算法**

  1）直接插入排序	2）冒泡排序	3）归并排序	4）基数排序

- **不稳定的算法**

  1）简单选择排序	2）快速排序	3）希尔排序	4）堆排序

- **每一趟排序结束至少能确定一个元素的最终位置的算法**

  1）简单选择排序	2）快速排序	3）堆排序

- **与序列初始状态有关的算法**

  **1）直接插入排序**	2）希尔排序	**3）冒泡排序**	4）快速排序	5）选择排序

- **与序列初始状态无关的算法**

  1）折半插入排序	2）基数排序	3）简单选择排序

- **若将顺序存储更换为链式存储，则算法的时间效率会降低的是**

  1）希尔排序	2）堆排序

- **若将顺序存储更换为链式存储，不影响时间效率的是**

  1）插入排序	2）选择排序	3）起泡排序

- **各排序算法空间时间复杂度的对比**

<img src="./数据结构/7.6.1-1.png" alt="7.6.1-1" style="zoom:90%;" />

#### 7.6.2 内部排序算法的应用

- **选取排序方法需要考虑的因素**

<img src="./数据结构/7.6.2-1.png" alt="7.6.2-1" style="zoom:90%;" />

- **排序算法小结**

<img src="./数据结构/7.6.2-2.png" alt="7.6.2-2" style="zoom:90%;" />

<img src="./数据结构/7.6.2-3.png" alt="7.6.2-3" style="zoom:90%;" />

