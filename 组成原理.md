## 第1章 计算机系统概述

### 1.2 计算机系统层次结构



#### 1.2.3 计算机软件的分类



2. **三个级别的语言**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2015-12,2016-12</font>

**1）机器语言**：又称二进制代码语言，需要编程人员记忆每条指令的二进制编码。**机器语言是计算机(硬件)唯一可以直接识别和执行的语言**。

**2）汇编语言**：汇编语言用英文单词或缩写代替二进制的指令代码，更容易为人们记忆和理解。使用汇编程序编辑的程序，**必须经过一个称为汇编程序的系统软件的翻译，将其转换成为计算机的机器语言**后，才能在计算机的硬件上执行。

**3）高级语言**：高级语言(如C、C++、Java等)是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。高级语言**需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序**，或**直接由高级语言程序翻译成机器语言程序**。

- **翻译程序、编译程序、解释程序、汇编程序**

**1）翻译程序**：是指把高级语言程序转换成机器语言(目标代码)的软件。翻译程序有两种：

​	**i）编译程序**：它将高级语言源程序一次翻译成目标程序，每次执行程序时，只需执行目标程序，因此只要源程序不变，就无须重新编译。

​	**ii）解释程序**：它将源程序的一条语句翻译成对应的机器目标代码，并立即执行，然后翻译下一条源程序语句并执行，直至所有源程序语句全部被翻译并执行完。

**2）汇编程序**：也是一种语言翻译程序，它把汇编语言源程序翻译为机器语言程序。汇编语言是一种面向机器的低级语言。



### 1.3 计算机性能指标

#### 1.3.1 计算机的主要性能指标

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2010-12,2011-12,2011-15,2012-12,2013-12,2014-12,2017-12</font>

1. **机器字长**

&emsp;&emsp;机器字长是指计算机**进行一次整数运算(即定点整数运算)**所能处理的**二进制数据的位数**，通常与**CPU的寄存器位数**、**加法器**有关。机器字长一般等于内部寄存器的大小，**字长越长，数的表示范围越大，计算精度越高**。计算机字长通常选定为字节(8位)的整数倍。不同计算机，字长可以不同。

**【注】：**

> **机器字长**：CPU一次能处理数据的位数，通常与CPU的寄存器位数有关。
>
> **存储字长**：存储器中一个存储单元(存储地址)所存储的二进制代码的位数，即存储器中的MDR的位数。
>
> **指令字长**：计算机指令字的位数。
>
> **数据字长**：计算机数据存储所占用的位数 

2. **数据通路带宽**

&emsp;&emsp;数据通路带宽是数据总线**一次所能进行并行传送信息的位数**。**这里所说的数据通路宽度是指外部数据总线的宽度**，它与CPU内部的数据总线宽度(内部寄存器的大小)有可能不同。

**【注】**各个子系统通过数据总线连接形成的数据传送路径称为数据通路。

3. **主存容量**

&emsp;&emsp;主存容量是指主存存储器所能存储的最大容量，**通常以字节来衡量**，也可以用**字数&times;字长(如512k&times;16位)**来表示存储容量。其中，**MAR的位数反映存储单元的个数**，MAR的位数**反映可寻址范围的最大值(而不一定是实际存储器的存储容量)**。

- 例子

<img src="./组成原理/1.3.1-1.png" alt="1.3.1-1" style="zoom:80%;" />

4. **运算速率**

**（1）吞吐量和响应时间**

- **吞吐量**：指系统在单位时间被处理请求的数量。它取决于信息能多快地输入内存，CPU能多块地取指令，数据能多块地从内存取出或存入，以及所得结果能多块地从内存送给一台外部设备。这些步骤中的每步都关系到主存，因此**系统吞吐量主要取决于主存的存储周期**。

- **响应时间**：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间。通常包括**CPU时间**(运行一个程序花费的时间)与**等待时间**(用与磁盘访问、存储器访问、I/O操作、操作系统开销等的时间)。

**（2）主频和CPU时钟周期**

- **CPU时钟周期**：通常为**节拍脉冲或T周期**，即**主频的倒数**，它**是CPU中最小的时间单位**，每个动作至少需要1个时钟周期。

- **主频(CPU的时钟频率)**：机器内部主时钟的频率，是衡量机器速度的重要参数。**主频的倒数是CPU的时钟周期**。**对于同一型号的计算机，其主频越高，完成指令的一个执行步骤所需的时间就越短，执行指令的速度就越快**。

**【注】**主频通常以MHz(兆赫兹)为单位，1HZ表示每秒一个时钟周期。

**（3）CPI(Clock cycle Per Instruction)**：即执行一条指令所需的时钟周期数。

**（4）CPU执行时间**：指运行一个程序所花费的时间
$$
\text{CPU}的执行时间=\text{CPU}时钟周期数/主频=(指令条数\times \text{CPI})/主频
$$
上述表明，CPU的性能(执行时间)取决于**① 主频 ② CPI ③ 指令条数**

**（5）MIPS、MFLOPS、GLOPS和TFLOPS**

- **MIPS(Million Instructions Per Second)**，即每秒执行多少百万条指令。

$$
MIPS=指令条数/(执行时间\times10^6)=主频/CPI
$$

- **MFLOPS(Mega Floating-point Operations Per Second)**，即每秒执行多少百万次浮点运算。

$$
MFLOPS=浮点操作次数/(执行时间\times10^6)
$$

- **GFLOPS(Giga Floating-point Operations Per Second)**，即每秒执行多少十亿次浮点运算。

$$
GFLOPS=浮点操作次数/(执行时间\times10^9)
$$

- **TFLOPS**(Tera Floating-point Operations Per Second)，即每秒执行多少万亿次浮点运算。

$$
TFLOPS=浮点操作次数/(执行时间\times10^{12})
$$

#### 1.3.2 几个专业术语

<img src="./组成原理/1.3.2-1.png" alt="1.3.2-1" style="zoom:80%;" />





## 第2章 数据的表示与运算

### 2.1 数制与编码



#### 2.1.4 字符与字符串



3. **字符串的存放**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2012-15,2016-14</font>

&emsp;&emsp;字符串是指连续的一串字符，通常方式下，它们占用主存中连续的多个字节，每个字节存储一个字符。主存字节由2B或4B组成时，在同一个主存字中，既可以按**先存储低位字节，后存储高位字节的顺序(即从低位字节向高位字节)**存放字符串的内容(**小端模式**)，又可以按**先存储低位字节，后存储高位字节的顺序(即从高位字节向低位字节)**存放字符串的内容(**大端模式**)。

- **例子**

<img src="./组成原理/2.4.1-1.png" alt="2.4.1-1" style="zoom:80%;" />



#### 2.1.5 校验码



2. **海明(汉明)校验码**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2013-15</font>

例子：在$n=4,k=3$时，求1010的海明码。

**（1）确定海明码的位数**

设$n$为有效信息的位数，$k$为校验位的位数，则信息位$n$和校验位$k$应满足
$$
n+k \le 2^k -1
$$
&emsp;&emsp;海明码位数为$n+k = 7 \le 2^3 -1$成立，则$n、k$有效。设信息位为$D_4D_3D_2D_1(1010)$，共4位，校验位为$P_3P_2P_1$，共3位，对应的海明码为$H_7H_6H_5H_4H_3H_2H_1$。

**（2）确定校验位的分布**

规定校验位$P_i$在海明位号为$2^{i-1}$的位置上，其余各位为信息位，因此有

<img src="./组成原理/2.1.5-1.png" alt="2.1.5-1" style="zoom:80%;" />

将信息位按原来的顺序插入，则海明码各位的分布如下：

<img src="./组成原理/2.1.5-2.png" alt="2.1.5-2" style="zoom:80%;" />

**（3）分组以形成校验关系**

&emsp;&emsp;每个数据位用多个校验位进行校验，但要满足条件：**被校验数据位的海明位号等于校验该数据位的各校验位海明位号之和**。另外，校验位不需再被校验。分组形成的校验关系如下：

<img src="./组成原理/2.1.5-3.png" alt="2.1.5-3" style="zoom:90%;" />

**（4）校验位取值**

校验位$P_i$的值为第$i$组(由该校验位校验的数据位)所有位求异或。

根据3）中的分组由

<img src="./组成原理/2.1.5-4.png" alt="2.1.5-4" style="zoom:80%;" />

所以，1010对应的海明码为1010010。

**（5）海明码的校验原理**

&emsp;&emsp;每个校验组分别利用校验位和参与形成该校验位的信息位进行奇偶校验检查，构成$k$个校验方程

<img src="./组成原理/2.1.5-5.png" alt="2.1.5-5" style="zoom:80%;" />

若$S_3S_2S_1=000$ 则说明无错；否则说明出错，且这个数就是错位的位号，如$S_3S_2S_1=001$说明第1位出错，即$H_1$出错，直接将该位取反就达到了纠错的目的。

**【注】**海明码“纠错”d位，需要码距为2d+1的编码方案；“检错”d位，只需码距为d+1。



### 2.2 定点数的表示与运算

#### 2.2.1 定点数的表示

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2011-43</font>

1. **无符号数和有符号数的表示**

**1）无符号数**：指整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值。若机器字长为8位，则数的表示范围为0~2<sup>8</sup>，即0~255。

**2）有符号数**：通常约定二进制数的最高位为符号位，即将符号位放在有效数字的前面，组成有符号数。有符号数的机器表示有**原码**、**补码**、**反码**和**移码**。用$[X]_{原}$表示原码，$[X]_{补}$表示补码，$[X]_{反}$表示反码，$[X]_{移}$表示移码。



2. **机器数的定点表示**

**（1）定点小数**

&emsp;&emsp;定点小数是纯小数，约定小数点位置在符号位之后、有效数值部分之前。设机器字长为n+1位，如图所示：

<img src="./组成原理/2.2.1-1.png" alt="2.2.1-1" style="zoom:80%;" />

**（2）定点整数**

&emsp;&emsp;定点整数是纯整数，约定小数点位置在有效数值最低位之后。设机器字长为n+1位，如图所示：

<img src="./组成原理/2.2.1-2.png" alt="2.2.1-2" style="zoom:80%;" />

<img src="./组成原理/2.2.1-3.png" alt="2.2.1-3" style="zoom:80%;" />



3. **原码、补码、反码、移码**

**（1）原码表示法**

- **纯小数的原码定义**

<img src="./组成原理/2.2.1-4.png" alt="2.2.1-4" style="zoom:80%;" />

例子：

<img src="./组成原理/2.2.1-5.png" alt="2.2.1-5" style="zoom:80%;" />

表示范围：若字长为n+1，$-(1-2^{-n})\le x \le 1-2^{-n}$（关于原点对称）

- **纯整数的原码定义**

<img src="./组成原理/2.2.1-6.png" alt="2.2.1-6" style="zoom:80%;" />

例子：

<img src="./组成原理/2.2.1-7.png" alt="2.2.1-7" style="zoom:80%;" />

表示范围：若字长为n+1，$-(2^n-1)\le x \le 2^n -1$（关于原点对称）

**【注】**真值的原码表示有正零和负零两种形式，即$[+0]_{原}=00000$和$[-0]_{原}=10000$

**（2）补码表示法**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2010-13,2014-13,2015-13</font>

- **纯小数的补码定义**

<img src="./组成原理/2.2.1-8.png" alt="2.2.1-8" style="zoom:80%;" />

例子：

<img src="./组成原理/2.2.1-9.png" alt="2.2.1-9" style="zoom:80%;" />

表示范围：若字长为n+1，$-1\le x \le 1-2^{-n}$（比原码多表示-1）

- **纯整数的补码定义**

<img src="./组成原理/2.2.1-10.png" alt="2.2.1-10" style="zoom:80%;" />

例子：

<img src="./组成原理/2.2.1-11.png" alt="2.2.1-11" style="zoom:80%;" />

表示范围：若字长为n+1，$-2^n \le x \le 2^n-1$（比原码多表示$-2^n$）

**【注】**真值零的补码表示是唯一的，即$[+0]_{补}=[-0]_{补}=0.0000$

- **由原码求补码**

<img src="./组成原理/2.2.1-12.png" alt="2.2.1-12" style="zoom:80%;" />

- **补码的算术移位**

将$[x]_{补}$的符号位与数值一起右移一位并保持原符号位的值不变，可实现除法功能(除以2)。

变形补码，又称为模4补码，双符号位的补码小数，其定义为

<img src="./组成原理/2.2.1-13.png" alt="2.2.1-13" style="zoom:80%;" />

模4补码双符号位00表示正，11表示负，用在完成算术运算的ALU部件中。

**（3）反码表示**

反码通常用来作为原码求补码或补码求原码的中间过度。

- **纯小数的反码定义**

<img src="./组成原理/2.2.1-15.png" alt="2.2.1-15" style="zoom:80%;" />

例子：

<img src="./组成原理/2.2.1-14.png" alt="2.2.1-14" style="zoom:80%;" />

表示范围：若字长为n+1，即$-(1-2^{-n}) \le x \le 1-2^{-n}$（关于原点对称）

**【注】**真值零的反码表示不唯一，负数的反码符号为“1”，数值部分求反，$[+0]_{反}=0.0000$，$[-0]_{反}=1.1111$

- **纯整数的反码定义**

<img src="./组成原理/2.2.1-16.png" alt="2.2.1-16" style="zoom:80%;" />

例子：

<img src="./组成原理/2.2.1-17.png" alt="2.2.1-17" style="zoom:80%;" />

表示范围：若字长为n+1，即$-(2^n-1)\le x\le 2^n-1$（关于原点对称）

- **真值、原码、补码及$[-x]_{补}$的转换规律**

<img src="./组成原理/2.2.1-18.png" alt="2.2.1-18" style="zoom:80%;" />

**（4）移码表示法**

移码常用来表示浮点数的阶码，它只能表示整数。
$$
[x]_{移}=2^n+x\quad (2^n > x\ge -2^n,其中机器字长为n+1)
$$
例子：

<img src="./组成原理/2.2.1-19.png" alt="2.2.1-19" style="zoom:80%;" />

- **移码的特点**

<img src="./组成原理/2.2.1-20.png" alt="2.2.1-20" style="zoom:80%;" />

**【注】**移码和补码的转换只改变符号位即可。

#### 2.2.2 定点数的运算

1. **定点数的移位运算**

**（1）算术移位**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2013-14</font>

&emsp;&emsp;算术移位的对象是**有符号数**，在移位过程中符号位保持不变。

<img src="./组成原理/2.2.2-1.png" alt="2.2.2-1" style="zoom:90%;" />

**（2）逻辑移位**

&emsp;&emsp;逻辑移位对象为**无符号数**。

**移位规则**：逻辑左移时，高位丢失，低位添0；逻辑右移时，低位丢失，高位添0。

**（3）循环移位**

&emsp;&emsp;循环移位分为**带进位标志位CF的循环移位**和**不带进位标志位的循环移位**。

<img src="./组成原理/2.2.2-2.png" alt="2.2.2-2" style="zoom:80%;" />

**特点**：循环移位操作适合将数据的低字节数据和高字节数据互换。

2. **原码定点数的加减运算**

设$[X]_原=x_sx_1...x_n$和$[Y]_原=y_sy_1...y_n$，进行加减运算的规则如下：

**加法规则**：先判符号位，若相同，则绝对值相加，结果符号位不变；若不同，则做减法，绝对值大的数减去绝对值小的数，结果符号位与绝对值大的数相同。

**减法规则**：两个原码表示的数相减，首先将减数符号取反，然后将被减数数与符号取反后的减数按原码加法进行运算。

3. **补码定点数加减法运算**

&emsp;&emsp;计算机普遍采用补码加减运算。补码运算的特点如下(设机器字长为n+1)。

<img src="./组成原理/2.2.2-3.png" alt="2.2.2-3" style="zoom:80%;" />
$$
\begin{array}{l}{[A+B]_{补}=[A]_{补}+[B]_{补}(\bmod M)} \\ 
{[A-B]_{补}=[A]_补+[-B]_{补}(\bmod M)}\end{array}
$$
**【注】**mod M运算是为了将溢出位丢掉。

- **例子**

<img src="./组成原理/2.2.2-4.png" alt="2.2.2-3" style="zoom:80%;" />



5. **溢出概念和判别方法**

&emsp;&emsp;溢出是指运算结果超过了数的表示范围。**仅当两个符号位相同相加或两个符号相异的数相减才可能产生溢出**。

<img src="./组成原理/2.2.2-5.png" alt="2.2.2-5" style="zoom:80%;" />

&emsp;&emsp;补码定点数加减运算溢出判断的方法：

**（1）采用一位符号位**

&emsp;&emsp;无论加法还是减法，只要参加操作的两个符号位相同，结果又与原操作符不同，则表示结果溢出。

&emsp;&emsp;设$A$的符号为$A_s$，$B$的符号位为$B_s$，运算结果符号位为$S_s$，则溢出表达式为
$$
V=A_{s} B_{s} \overline{S_{s}}+\overline{A_{s} B_{s}} S_{s}
$$
若$V=0$，表示无溢出；若$V=1$，表示有溢出。

**（2）采用双符号位**

&emsp;&emsp;双符号位也称为模4补码。运算结果的**两个符号位$S_{s1}S_{s2}$相同，表示未溢出；运算结果的两位数$S_{s1}S_{s2}$不同，表示溢出**。此时**最高位符号位代表真正的符号**。

① $S_{s1}S_{s2}=00$：表示结果为正，无溢出

② $S_{s1}S_{s2}=01$：表示结果正溢出

③ $S_{s1}S_{s2} = 10$：表示结果负溢出

④ $S_{s1}S_{s2} = 11$：表示结果为负数，无溢出

**（3）采用一位符号位根据数据位的进位情况判断溢出**

&emsp;若符号位的进位$C_s$与最高数位进位$C_1$相同时，则说明无溢出，否则发生溢出。



#### 2.2.3 强制类型转换

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-12,2010-14,2012-13,2016-13</font>

1. **有符号$\rightarrow$无符号**

```c
int main() {
    short x = -4321;
    unsigned short y = (unsigned short)x;
    printf("x=%d, y=%u\n",x,y);
}
```

![2-2-1](./组成原理/2-2-1.png)

其中，$x$为补码表示，$y$为无符号真值。

2. **无符号$\rightarrow$有符号**

```C
int main() {
    unsigned short x = 65535;
    short y = (short)x;
    printf("x=%u, y=%d\n",x,y);
}
```

在采用补码的机器上，$x=65535, y=-1$

3. **大字长$\rightarrow$小字长**

```C
int main() {
 	int x = 165537, u = -34991;			//int型占用4B
    short y = (short)x, v = (short)u;	//short占用2B
    printf("x=%d, y=%d\n",x,y);
    printf("u=%d, v=%d\n",u,v);
}
```

这段程序的结果为：

>$x = 165537, y = -31071$
>
>$u=-34991, v = 30545$

其中$x,y,u,v$的16进制表示分别为0x000286a1，0x86a1，0xffff7751，0x7751。

**原则总结：**当大字长变量向小字长变量强制类型转换时，系统把多余的高位字长部分直接截断，低位直接赋值。

4. **小字长$\rightarrow$大字长**

```c
int main() {
 	short x = -4321;
    int y = x;
    unsigned short u = (unsigned short)x;
    unsigned int v = u;
    printf("x=%d, y=%d\n",x,y);
    printf("u=%d, v=%d\n",u,v);
}
```

这段程序的结果为：

> $x = -4321, y = -4321$
>
> $u=61215, v = 61215$

其中$x,y,u,v$的16进制表示分别为0xef1f，0xffffef1f，0xef1f，0x0000ef1f

**原则总结：**当小字长变量向大字长变量强制类型转换时，不仅要使相应的位值相等，高位部分还会扩展为原数字的符号位。



### 2.3 浮点数的表示与运算

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2017-43</font>

#### 2.3.1 浮点数的表示

1. **浮点数的表示格式**

&emsp;&emsp;通常，浮点数表示为
$$
N=r^E \times M
$$
其中，$r$是浮点数的阶码的底，与尾数的基数相同，通常$r=2$。$E$为阶码，$M$为尾数。

![2.3.1-1](./组成原理/2.3.1-1.png)

&emsp;&emsp;阶码是整数，**阶符$J_f$和阶码的位数$m$共同反映浮点数的表示范围及小数点的实际位置**。数符$S_f$代表浮点数的符号，**尾数的位数$n$反映浮点数的精度**。

2. **规格化浮点数**

- **左规**：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数左移一位，阶码减1(基数为2时)。**左规可能要进行多次**。
- **右规**：当浮点数运算的结果尾数出现溢出(双符号为01或10)时，将尾数算术右移一位、阶码加1(基数为2时)。**需要右规时，只需要进行一次**。

规格化浮点数的尾数$M$应满足条件$1/r \le |M| \le 1$。

<img src="./组成原理/2.3.1-2.png" alt="2.3.1-2" style="zoom:85%;" />

**【注】**

- 当浮点数尾数的基数为2时，原码规格化数的尾数最高位一定为1，补码规格化数的尾数最高位一定与尾数符号位相反。
- 当浮点数尾数的基数为4时，原码规格化形式的尾数最高两位不全为0。
- 当浮点数尾数的基数为8时，原码规格化形式的尾数最高三位不全为0。

4. **IEEE 754 标准**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2011-13,2012-14,2013-13，2014-14</font>

<img src="./组成原理/2.3.1-3.png" alt="2.3.1-3" style="zoom:85%;" />

&emsp;&emsp;IEEE 754 标准规定了常用的浮点格式有短浮点数(单精度、float型)、长浮点数(双精度、double型)、临时浮点数

<img src="./组成原理/2.3.1-4.png" alt="2.3.1-4" style="zoom:80%;" />

【注1】**短浮点数与长浮点数都采用隐含尾数最高数位的方法，故可多表示一位数。临时浮点数又称扩展精度浮点数，无隐含位**。

【注2】**短浮点数的有效位为24位，长浮点数有效位为53位**。

【注3】**IEEE 754标准用“阶码全1、尾数全0”表示无穷大**

> 例如，$(12)_{10}=(1100)_2$，将它规格化后结果为$1.1 \times 2^3$，其中整数部分“1”将不存储在23位尾数内。

&emsp;&emsp;IEEE 754标准中，规格化的短浮点数的真值为
$$
(-1)^s \times 1.M \times2^{E-127}
$$

&emsp;&emsp;规格化长浮点数的真值为
$$
(-1)^s \times 1.M \times2^{E-1023}
$$

- **IEEE 745浮点数的范围**

<img src="./组成原理/2.3.1-5.png" alt="2.3.1-5" style="zoom:80%;" />

5. **定点、浮点表示的区别**

<img src="./组成原理/2.3.1-6.png" alt="2.3.1-6" style="zoom:80%;" />





#### 2.3.2 浮点数的加减运算

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-13,2015-14</font>

&emsp;&emsp;浮点数运算特点是**阶码运算和尾数运算分开进行**，浮点数的**加减运算一律采用补码**。浮点数的加减运算分以下几步：

1. **对阶**

**小阶向大阶对齐原则**：阶码小的尾数右移一位(基数为2)，阶加1，直到两个数的阶码相等为止。

2. **尾数求和**

将对阶后的尾数按定点数加减运算规则运算。

3. **规格化**

以双符号为例，当尾数大于0时，其补码规格化形式为
$$
[S]_{补}=00.1**
$$
当尾数小于0时，其补码规格化形式为
$$
[S]_{补}=11.0**
$$
可见，当尾数的最高位数值位与符号位不同时，即为规格化形式。规格化分为左规与右规两种：

**1）左规**：当尾数出现00.0&times;&times;&times;或11.1&times;&times;&times;时，需左规，即**尾数左移1位，和的阶码减1**，知道尾数为00.1&times;&times;&times;或11.0&times;&times;&times;。

**2）右规**：当尾数求和结果溢出(如尾数为10.&times;&times;&times;或01.&times;&times;&times;时，需右规，即**尾数右移一位，和的阶码加1**。

**【注】**

- **左规相当于乘2，右规相当于除2**。
- $[-1/2]_{补}=1.1000$不是规格化数，需要左规一次，$[-1]_{补}=1.0000$才是规格化数。

4. **舍入**

在对阶和右规的过程中，可能会将尾数低位丢失，引起误差，影响精度。

**1）“0”舍“1”入法**：在尾数右移时，被移去的最高位为0时，则舍去；被移去的最高数值位为1时，则在尾数的末位加1。这样做可能使尾数又溢出，此时需要再做一次右规。

**2）恒置“1”法**：尾数右移时，不论丢掉的最高位数值位是“1”还是"0"，都使右移后的尾数末位恒置"1"。

5. **溢出判断**

- 当尾数出现10.&times;&times;&times;或01.&times;&times;&times;时，并不表示溢出，只能将此数右规后，再根据阶码来判断运算结果是否溢出。
- 浮点数的溢出与否是由阶码的符号决定的。以双符号位补码为例子，当阶码的符号位出现“01”时，即**阶码大于最大阶码时**，表示**上溢**。当阶码的符号位出现“10”时，即**阶码小于最小阶码时**，表示**下溢**。

**【注】**

① 对阶操作不会引起阶码上溢或下溢。

② 右规和尾数舍入都可能引起阶码上溢。

③ 左规时可能引起阶码下溢。

④ 尾数溢出时结果不一定溢出。



## 第3章 存储系统

### 3.3 半导体随机存储器

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2010-16,2011-14,2013-29</font>



#### 3.3.2 SRAM和DRAM

1. **SRAM的工作原理**

&emsp;&emsp;通常把一个二进制的物理器件称为**存储元**，它是存储器的最基本的构建。地址码相同的多个存储元构成一个**存储单元**。若干存储单元构成一个**存储体**。

&emsp;&emsp;**静态随机存储器(SRAM)**的存储单元是用**双稳态触发器(六管MOS)**来记忆信息的，因此信息被读出后，它仍保留其原状态而不需再生**(非破坏性读出)**。但是，只要电源被切断，原来的信息便会丢失，故它属于**易失性半导体存储器**。

- **特点**：存储速度快，但集成度低，功耗大，所以一般用来组成**高速缓冲存储器**。

2. **DRAM的工作原理**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2014-15,2015-17</font>

&emsp;&emsp;与SRAM的存储原理不同，**动态随机存储器(DRAM)**是利用存储单元电路中**栅极电容上的电荷**来存储信息的，常见的DRAM的基本存储电路通常分为**三管式**和**单管式**。DRAM采用**地址复用技术**，地址线是原来的1/2，且地址信号分行、列两次传送。

- **特点**：相对于SRAM来说，DRAM具有容易集成、低价位、容量大和功耗低等优点，但DRAM的存取速度比SRAM的慢，一般用来组成**大容量主存系统**。

&emsp;&emsp;DRAM电容上的电荷一般只能维持1~2ms，因此即使电源不掉电，信息也会自动消失。为此，每隔一定时间必须刷新，通常取**2ms，这个时间为刷新周期**。常用的刷新方式有3种，集中刷新、分散刷新和异步刷新。

**（1）集中刷新**

&emsp;&emsp;指在一个刷新周期内，利用一段固定的时间，**依次对存储器所有行进行逐一再生，在此期间停止对存储器的读写操作**，称为**“死时间”**，又称为**“死区”**。

- **优点**：读写操作时不受刷新工作的影响，因此系统的存取速度较高
- **缺点**：在集中刷新期间(死区)不能访问存储器

**（2）分散刷新**

&emsp;&emsp;把**对每行的刷新分散到各个工作周期中**。这样，一个存储器的系统工作周期分为两部分：**前半部分正常读、写或保持；后半部分用于刷新某一行**。这种刷新方式增强了系统的存取周期，如存储芯片的存取周期为0.5us，则系统的存取周期为1us。

- **优点**：没有死区。
- **缺点**：加长了系统的存取周期，降低了整机的速度。

**（3）异步刷新**

&emsp;&emsp;异步刷新是前两种方法的结合，它既可以缩短“死时间”，又能充分利用最大刷新时间间隔为2ms的特点。具体做法是将**刷新周期除以行数**，得到两次刷新操作之间的时间间隔t，利用逻辑电路每隔时间t产生一次刷新请求。这样可以**避免使CPU连续等待过长的时间，而且减少了刷新次数，从根本上提高了整机的工作效率**。

**【注】**若将刷新安排在不需要访问存储器的译码阶段，则既不会加长存取周期，又不会产生“死时间”，这是分散刷新方式的发展，也称为**“透明刷新”**。

- **DRAM刷新需要注意的问题**

① **刷新对CPU是透明的**，即刷新不依赖于外部的访问；

② **动态RAM的刷新单位是行**，故刷新操作时仅需要行地址；

③ 刷新操作类似于读操作，但又有所不同。**刷新操作仅给栅极电容补充电荷，不需要信息输出**。另外，**刷新时不需要选片，即整个存储器中的所有芯片同时被刷新**。

**【注】**易失性存储器是指断电后数据会丢失。



4. **SRAM和DRAM的比较**

<img src="./组成原理/3.3.2-1.png" alt="3.3.2-1" style="zoom:90%;" />

**【注】**计算机开机后，操作系统最终被加载到RAM。



#### 3.3.3 只读存储器ROM

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2012-16</font>

1. **只读存储器的特点**

ROM和RAM都是支持**随机存取**的存储器，其中SRAM和DRAM均为易失性存储器。而ROM中一旦有了信息，就不能轻易改变，即使掉电了也不会丢失，它在计算机系统中只供读出的存储器。

​		1）**结构简单**，位密度比可读可写存储器的高。

​		2）具有**非易失性**，所以可靠性高。

2. **ROM的类型**

   1）掩膜式只读存储器MROM

   2）一次可编程只读存储器PROM

   3）可擦除可编程只读存储器EPROM

   4）闪速存储器(Flash Memory)

   5）固态硬盘(Solid State Driver，SSD)





### 3.4 主存储器与CPU的连接

#### 3.4.2 主存容量的扩展

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-15,2010-15,2016-16</font>

1. **位扩展(并联)**

&emsp;&emsp;位扩展是使存储芯片的数据位数与CPU的数据线数相等。如图，用8片8K&times;1位的RAM芯片组成8K&times;8位的存储器。8位RAM芯片的地址线$A_{12}$~$A_0$、片选信号$\overline{CS}$、读写控制线$\overline{WE}$都分别连在一起，每片的数据线依次作为CPU数据线的一位。

![3.4.2-1](./组成原理/3.4.2-1.png)

2. **字扩展(串联)**

&emsp;&emsp;字扩展是指增加存储器中字的数量，而位数不变。如图，用4片16K&times;8位的RAM芯片组成64K&times;8位的存储器。4片RAM芯片的数据线$D_0$~$D_7$和读写控制线$\overline{WE}$都分别连在一起。将$A_{15}A_{14}$用作片选信号，$A_{15}A_{14}=00$时，译码输出端0有效，选最左边的1号芯片；$A_{15}A_{14}=01$时，译码输出端1有效，选中2号芯片，以此类推(在同一时间内只能有一个芯片被选中)

<img src="./组成原理/3.4.2-2.png" alt="3.4.1-2" style="zoom:85%;" />

![3.4.1-3](./组成原理/3.4.2-3.png)

3. **字位同时扩展法**

&emsp;&emsp;字位同时扩展既增加了存储字的数量，又增加了存储字长。如图，用用8片16K&times;4位的RAM芯片组成64K&times;8位的存储器。每两片构成一组16K&times;8位的存储器**(位扩展)**，4组便构成64K&times;8位**(字扩展)**。

![3.4.2-4](./组成原理/3.4.2-4.png)

### 3.5 双端口RAM和多模块存储器

&emsp;&emsp;为了提高CPU访问存储器的速度，可以采用双端口存储器、多模块存储器等技术，它们属于并行技术，**前者为空间并行，后者为时间并行**。

#### 3.5.1 双端口RAM

&emsp;&emsp;双端口RAM是指同一个存储器有左、右两个独立的端口，分别具有两组相互独立的地址线、数据线和读写控制线，允许两个独立的控制器同时**异步地**访问存储单元。当两个端口的地址不相同时，在两个端口上进行读写操作一定不会发生冲突。

<img src="./组成原理/3.5.1-1.png" alt="3.5.1-1" style="zoom:80%;" />

&emsp;&emsp;两个端口同时存取存储器的同一地址单元时，会因数据冲突造成数据存储或读取错误。两个端口对同一主存操作有以下4种情况：<img src="./组成原理/3.5.1-2.png" alt="3.5.1-2" style="zoom:80%;" />

其中，第1）种和第2）种情况不会出现错误；第3）种情况会出现写入错误；第4）种会出现读出错误。

&emsp;&emsp;**解决方法**：置“忙”信号$\overline{BUSY}$为0，由此判断逻辑决定暂时关闭一个端口(即被延时)，未被关闭的端口正常访问，被关闭的端口延长一个很短的时间后再访问。

#### 3.5.2 多模块存储器

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2015-15,2017-13[重]</font>

&emsp;&emsp;为提高访存速度，常采用多模块存储器，常用的有**单体多字存储器**和**多体低位交叉存储器**。

**【注】**CPU的速度比存储器的快，若同时从存储器中取出n条指令，就可充分利用CPU资源，提高运行速度，多体交叉存储器就是基于这种思想提出的。

1. **单体多字存储器**

&emsp;&emsp;单体多字存储系统的特点是**存储器中只有一个存储体**，**每个存储单元存储m个字**，**总线宽度也为m个字**。一次并行读出m个字，地址必须顺序排列并处于同一个存储单元。

&emsp;&emsp;**单体多字系统在一个存取周期内，从同一地址取出m条指令**，然后将指令逐条送至CPU执行，即每隔1/m存取周期，CPU向主存取出一条指令。显然，这增大了存储器的带宽，提高了单体存储器的工作速度。

&emsp;&emsp;**缺点**：指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或操作数不能连续存放，这种方法的效果就不明显。

2. **多体并行存储器**

&emsp;&emsp;多体并行存储器由**多体模块**组成。每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作。

&emsp;&emsp;多体并行存储器分为**高位交叉编址(顺序方式)**和**低位交叉编制(交叉方式)**两种。

**1）高位交叉编址**：高位地址表示体号，低位地址为体内地址，如图所示

**【注】**由于采用高位交叉编制，故**采用高位交叉编制方式的存储区仍是顺序存储器**。

<img src="./组成原理/3.5.2-1.png" alt="3.5.2-1" style="zoom:80%;" />

**2）低位交叉编址(重点)**：低位地址为体号，高位地址为体内地址，如图所示。由于程序连续存放在相邻体中，因此称采用此编制方式的存储器称为交叉存储器。

&emsp;&emsp;多体模块结构的存储器采用低位交叉编址后，可**在不改变每个模块存取周期的前提下，采用流水线的方式并行存储，提高存储器的带宽**。

<img src="./组成原理/3.5.2-2.png" alt="3.5.2-2" style="zoom:80%;" />

&emsp;&emsp;设模块字长等于数据总线宽度，模块**存取一个字的周期为**$T$，**总线传送周期为**$r$，为实现流水线方式存取，存储器**交叉模块数大于等于**
$$
m =T/r
$$
其中，$m$称为交叉存取度。每经过$r$时间延迟后启动下一个模块，交叉存储器要求其模块数必须大于等于$m$，以保证启动某模块后经过$m \times r$的时间后再次启动模块时，其上次的存取操作已经完成(即流水线不间断)。这样，连续存取$m$个字所需的时间为
$$
t_1 = T +(m-1)r
$$
而顺序方式连续读取$m$个字所需的时间为$t_2 = mT$。可见低位交叉存储器的带宽大大提高。模块数为4的流水线方式存取示意图：

<img src="./组成原理/3.5.2-3.png" alt="3.5.2-3" style="zoom:80%;" />

**【注】**模块序号 = 访存地址 % 存储器交叉模块数

- **例子**

<img src="./组成原理/3.5.2-4.png" alt="3.5.2-4" style="zoom:80%;" />



### 3.6 高速缓冲存储器Cache

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-21,2014-16,2015-15,2016-15</font>

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2010-44[重],2011-44,2013-43,2014-45,2016-45</font>

#### 3.6.1 程序访问的局部性原理

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2017-14</font>

- **时间局部性**：最近的未来要用到的信息，很可能是现在正在使用的信息，因为程序存在循环。
- **空间局部性**：最近的未来要用到的信息，很可能与现在使用的信息在存储空间上是邻近的，因为指令通常是顺序存放、顺序执行的。数据一般也是以向量、数组、表等形式簇聚第存储在一起的。

高速缓冲技术就是利用程序访问的局部性原理。



#### 3.6.2 Cache的基本工作原理

&emsp;&emsp;Cache位于存储器层次结构的顶层，**通常由SRAM构成**，其基本结构如图

<img src="./组成原理/3.6.2-1.png" alt="3.6.2-1" style="zoom:80%;" />

&emsp;&emsp;Cache和主存都被划分成若干相等的块(Cache块又称Cache行)，每块由若干字节组成，块的长度称为块长(Cache行长)。由于Cache的容量远小于主存的容量，所以Cache中的块数要远少于主存中的块数，它保留主存中最活跃的若干块的副本。故Cache安照某种策略，预测CPU在未来一段时间内欲访存的数据，将其装入Cache。

&emsp;&emsp;当CPU发出读请求时，若访存地址在Cache中命中，就将此地址转换成Cache地址，直接对Cache进行读操作，与主存无关；若Cache不命中，则仍需访问主存，并把次字所在的块一次性地从主存调入Cache。若Cache已经满了，则根据某种替换算法，用这个块替换Cache中原来的某块信息。

【注】**CPU与Cache之间的数据交换以字为单位，而Cache与主存之间的数据交换以Cache块为单位**。

- **Cache命中率**

$$
H = N_c/(N_c+N_m)
$$

其中$N_c$是Cache总命中次数，$N_m$是主存访问总次数。

- **Cache-主存系统平均访问时间**

$$
T_a = Ht_c+(1-H)t_m
$$

其中$t_c$为命中时的Cache访问时间，$t_m$为未命中时的访问时间，$1-H$表示未命中率。

- **例子**

<img src="./组成原理/3.6.2-2.png" alt="3.6.2-2" style="zoom:80%;" />



#### 3.6.3 Cache和主存的映射方式

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-14</font>

1. **直接映射**

- **映象规则**：主存中一块只能映象到Cache特定的一块中。

- Cache地址**计算公式**：

$$
b=B \ \text{mod} \ C_b
$$

其中，$b$是**Cache的块号**(又称Cache的行号)，$B$是**主存的块号**，$C_b$是**Cache中的总块数**。

- **主存地址结构**：

<img src="./组成原理/3.6.3-1.png" alt="3.6.3-1" style="zoom:80%;" />

- **映象关系图**

<img src="./组成原理/3.6.3-2.png" alt="3.6.3-2" style="zoom: 67%;" />

- **直接映象方式的地址变换过程**

用主存地址中的块号B去访问区号存储器，把读出来的区号与主存地址中的区号E进行比较：

1）比较结果相等，有效位为1，则Cache命中，否则该块已
经作废。

2） 比较结果不相等，有效位为1，Cache中的该块是有用的，
否则该块是空的。

<img src="./组成原理/3.6.3-11.png" alt="3.6.3-2" style="zoom: 67%;" />



2. **全相联映射**

- **映象规则**：主存的任意一块可以映象到Cache中的任意一块(映射关系有$C_b \times M_b$种)。

- **主存地址结构**

  ![3.6.3-5](./组成原理/3.6.3-5.png)

- **映象关系图**

<img src="./组成原理/3.6.3-3.png" alt="3.6.3-3" style="zoom: 67%;" />

- **地址变换规则**

<img src="./组成原理/3.6.3-12.png" alt="3.6.3-2" style="zoom: 67%;" />



3. **组相联映射**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2012-17</font>

- **映象规则**
  - 主存和Cache按同样大小划分成块和组
  - 主存和Cache组之间采用直接映象方式
  - 在两个对应的组内采用全相联映象方式

- **主存地址结构**

![3.6.3-6](./组成原理/3.6.3-6.png)

- **映象关系图**

<img src="./组成原理/3.6.3-7.png" alt="3.6.3-7" style="zoom: 67%;" />

- **组相联映象的地址变过程**

1）用主存地址中的组号G按地址访问块表存储器。把读出来的一组区号和块号与主存地址中的区号和块号进行
相联比较。

2）如果有相等的，表示Cache 命中。

3）如果全部不相等，表示Cache 没有命中。

<img src="./组成原理/3.6.3-13.png" alt="3.6.3-7" style="zoom: 67%;" />



- **例子【重点】**

<img src="./组成原理/3.6.3-8.png" alt="3.6.3-8" style="zoom:80%;" />

<img src="./组成原理/3.6.3-9.png" alt="3.6.3-9" style="zoom:80%;" />

<img src="./组成原理/3.6.3-10.png" alt="3.6.3-10" style="zoom:80%;" />



#### 3.6.4 Cache中主存块的替换算法

<img src="./组成原理/3.6.4-1.png" alt="3.6.4-1" style="zoom:80%;" />



#### 3.6.5 Cache的写策略

&emsp;&emsp;因为Cache中的内容是主存块副本，当对Cache中的内容进行更新时，就需要选用写策略使Cache内容与主存内容保持一致。此时分两种情况：

- **全写法(写直通法，write-through)**

&emsp;&emsp;**当CPU对Cache写命中时，必须把数据同时写入Cache和主存**。当**某一块需要替换时，不必把这一块写回主存，用新调入的块直接覆盖即可**。

**1）优点**：方法实现简单，能随时保持主存数据的正确性。

**2）缺点**：增加了访存次数，降低了Cache效率。

**写缓冲**：为减少全写直接写入主存的时间损耗，在Cache和主存之间加一个写缓冲(Write Buffer)。CPU同时写数据到Cache和写缓冲中，写缓冲再控制将内容写入主存。写缓冲是一个**FIFO队列**，写缓冲可以解决速度不匹配的问题，但若出现写频繁时，会使得缓冲饱和溢出。

<img src="./组成原理/3.6.5-1.png" alt="3.6.5-1" style="zoom:80%;" />

- **写回法(write-back)**

**&emsp;&emsp;当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存**。这种方法减少了访存次数，但存在不一致的隐患。采用这种策略，对每个Cache行必须设置一个**标志位(脏位)**，以反映次块是否被CPU修改过。

对于Cache写不命中，也有两种处理方法。

**1）写分配法(write-allocate)**：加载主存中的块到Cache中，然后更新这个Cache块。它试图利用程序的空间局部性，但缺点是每次不命中都需要从主存中读取一块。

**2）非写分配法(not-write-allocate)**：只写入主存，不进行调块。

**非写分配法通常与全写法合用，写分配法通常和写回法合用**。

- **例子**

<img src="./组成原理/3.6.5-2.png" alt="3.6.5-2" style="zoom:80%;" />



### 3.7 虚拟存储器

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2011-44</font>

#### 3.7.2 页式虚拟存储器

&emsp;&emsp;以页为基本单位的虚拟存储器称为页式虚拟存储器。虚拟空间与主存空间都划分成同样大小的页，**主存的页称为实页，虚存的页称为虚页**。**页表是一张存放在主存中的虚页表和实页表对照表**，它记录程序的虚页调入主存时被安排在主存中的位置。

&emsp;&emsp;**页表基址寄存器存放当前运行程序的页表起始地址，它和虚页号拼接成页表项地址**，每个页表项记录与某个虚页对应的**虚页号**、**实页号**和**装入位**等信息。**装入位为“1”，表示该页面已经在主存中，将对应的实页号和虚拟地址中的页内地址拼接，得到完整地址**。装入位为“0”，表示该页面不在内存中，此时要启动I/O系统，把该页面从辅存调入主存后再供CPU使用。

<img src="./组成原理/3.7.2-1.png" alt="3.7.2-1" style="zoom:80%;" />

**【注】**Cahce缺失处理的时间开销比页表缺失处理的时间开销小，因为缺页处理需要访问磁盘，而Cache'缺失只需要访问主存。



#### 3.7.5 快表(TLB)

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2010-17,2011-16,2015-16</font>

&emsp;&emsp;在页式或段式或段页式虚拟存储器中必须先去一次主存查页表或段表才取得数据。快表利用了**局部性原则**。快表存放在**高速缓冲器**中，**慢表(Page)**存放在**内存**中。快表只是慢表的一个副本，而且只存放了慢表中很少的一部分。

**【注1】**TLB是Page的一个很小副本，所以若TLB命中则Page一定命中。

**【注2】**在同时具有虚拟页式存储器(有TLB)和Cache的系统中，访问的顺序为：**TLB$\rightarrow$页表$\rightarrow$Cache$\rightarrow$主存**。CPU发出访存命令(逻辑地址)，先查找TLB和Page，将逻辑地址转换为物理地址，再查找相应的Cache块(与主存查找并行)。

:star:**【注3】**若Cache命中，则说明所需页面已调入主存，Page必然命中，但TLB不一定命中；若Cache不命中，则并不能说明所需的页面未调入主存，和TLB和Page命中与否没有关系；若Page不命中，则说明所需页面未调入主存，当然Cache和快表也不会命中，执行调页策略。

**【注4】**Cache采用**组相联存储器**件组成，按照内容访问，因此比慢表查找速度快



#### 3.7.6 虚拟存储器与Cache的比较

1. **相同之处**

<img src="./组成原理/3.7.6-1.png" alt="3.7.6-1" style="zoom:80%;" />

2. **不同之处**

<img src="./组成原理/3.7.6-2.png" alt="3.7.6-2" style="zoom:80%;" />



## 第4章：指令系统

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2010-43,2013-44,2015-44,2017-44</font>

### 4.1 指令的基本格式

&emsp;&emsp;指令(又称为机器指令)是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。一台计算机的**所有指令的集合构成该机的指令系统**，也称为指令集。

#### 4.1.1 指令的基本格式

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2017-16</font>

<img src="./组成原理/4.1.1-1.png" alt="4.1.1-1" style="zoom:80%;" />

- **操作码**：指出指令中该指令应该执行什么性质的操作和具有何种功能

- **地址码**：指出被操作的信息(指令或数据)的地址，包括参加运算的一个或多个操作数所在地址、运算结果的保存地址、程序的转移地址、被调用的子程序的入口地址等

1. **零地址指令**

<img src="./组成原理/4.1.1-2.png" alt="4.1.1-2" style="zoom:80%;" />

2. **一地址指令**

<img src="./组成原理/4.1.1-3.png" alt="4.1.1-3" style="zoom:80%;" />

3. **二地址指令**

<img src="./组成原理/4.1.1-4.png" alt="4.1.1-4" style="zoom:80%;" />

若指令字长为32位，操作码占8位，两个地址码子段各占12位，则指令操作数的直接寻址范围为$2^{12}=4K$。

4. **三地址指令**

<img src="./组成原理/4.1.1-5.png" alt="4.1.1-5" style="zoom:80%;" />

5. **四地址指令**

<img src="./组成原理/4.1.1-6.png" alt="4.1.1-6" style="zoom:80%;" />



#### 4.1.2 定长操作码指令格式

&emsp;&emsp;定长操作码指令在指令字的最高位部分分配固定的若干位(定长)表示操作码，**一般n位操作码字段的指令系统最大能够表示$2^n$条指令**。



#### 4.1.3 扩展操作码指令格式

<img src="./组成原理/4.1.1-7.png" alt="4.1.1-7" style="zoom:80%;" />

- **例子**

<img src="./组成原理/4.1.1-8.png" alt="4.1.1-8" style="zoom:80%;" />

- **需注意的问题**

1）不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分相同。

2）各指令的操作码一定不重复。



### 4.2 指令寻址方式

&emsp;&emsp;寻址方式是指寻找指令或操作数有效地址，即确定本条指令的数据地址及下一条待执行指令的地址的方法。

**【注1】A：形式地址**	**EA：有效地址**

**【注2】**\(A\)表示地址为A的数值，A既可以是寄存器编号，也可以是内存地址。对应(A)就是寄存器中的数值，或相应内存单元的数值。

**【注3】**EA=(A)意思是有效地址是地址A中的值。

#### 4.2.1 指令寻址和数据寻址

&emsp;&emsp;寻址方式分为指令寻址和数据寻址两大类。寻找下一条要执行的指令地址称为**指令寻址**；寻找操作数的地址称为**数据寻址**。

1. **指令寻址**

   **1）顺序寻址**：通过**程序计数器(PC)加1**(1个指令字长)，自动形成下一条指令的地址。

   **2）跳跃寻址：**所谓跳跃，是指下条指令的地址码不由程序计数器给出，而由本条指令给出下条下条指令地址的计算方式。

   【注】是否跳跃可能受到**状态寄存器**和**操作数**的控制，而跳跃到的地址分为**绝对地址**(由标记符直接得到)和**相对地址**(相对于当前指令地址的偏移量)，跳跃的结果是当前指令修改PC值，所以**下一条指令仍然通过程序计数器(PC)给出**。

2. **数据寻址**

&emsp;&emsp;数据寻址是指如何在指令中表示一个操作数的地址，如何用这种表示得到操作数或怎样计算出操作数的地址。

![4.2.1-1](./组成原理/4.2.1-1.png)

#### 4.2.2 常见的数据寻址方式

1. **隐含寻址**

&emsp;&emsp;这种类型的指令不明显地给出操作数的地址，而在指令中隐含操作数的地址。

> 例：**单地址**的指令格式就不明显地在地址字段中指出第二个操作数的地址，规定**累加器(ACC)**作为第二个操作数地址。累加器(ACC)对单地址指令来说就是隐含寻址。

**优点**：缩短指令字长

**缺点**：增加存储器操作数或隐含地址的硬件。

<img src="./组成原理/4.2.2-1.png" alt="4.2.2-1" style="zoom:80%;" />

2. **立即(数)寻址**

&emsp;&emsp;这种类型的指令的地址字段直接指出的不是操作数的地址，而是操作数的本身，又称为**立即数**。**数据采用补码的形式存放**。

**优点**：不访问主存，执行时间短。

**缺点**：A的位数限制了立即数的范围。

<img src="./组成原理/4.2.2-2.png" alt="4.2.2-2" style="zoom:80%;" />

3. **直接寻址**

指令中的**形式地址A是操作数的真实地址EA**，即**EA=A**。

**优点**：简单，指令仅访问一次主存。

**缺点**：A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改。

<img src="./组成原理/4.2.2-3.png" alt="4.2.2-3" style="zoom:80%;" />

4. **间接寻址**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2011-16,2016-17</font>

&emsp;&emsp;**间接寻址是相对于直接寻址而言的**，指令的地址字段给出的形式地址不是操作数地址，而是操作数有效地址所在的存储单元，即**操作数地址的地址**，即**EA = (A)**。间接寻址可以是一次间接寻址，也可以是多次间接寻址。

**优点**：可扩大寻址范围(**有效地址EA的位数大于形式地址A的位数**)，便于编制程序(**用间接寻址可方便完成子程序的返回**)

**缺点**：指令在执行阶段需要多次访存，增大了时间开销。

<img src="./组成原理/4.2.2-4.png" alt="4.2.2-4" style="zoom:80%;" />

5. **寄存器寻址**

&emsp;&emsp;寄存器寻址是指在指令字中直接给出操作数所在的寄存器编号，即$EA=R_i$，其操作数在$R_i$所指的寄存器内。

**优点**：不需要访问主存，执行速度快，**支持向量/矩阵运算**。

**缺点**：寄存器价格昂贵，计算机中的寄存器个数有限。

6. **寄存器间接寻址**

&emsp;&emsp;寄存器间接寻址是指在寄存器$R_i$中给出的不是操作数，而是操作数所在主存单元的地址，即$EA=(R_i)$。

**优点**：比一般间接寻址相比速度更快。

**缺点**：需要访问主存

<img src="./组成原理/4.2.2-5.png" alt="4.2.2-5" style="zoom:80%;" />

7. **相对寻址**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-16</font>

&emsp;&emsp;相对寻址是把程序计数器(PC)的内容加上形式地址A而形成的操作数的有效地址，即**EA=(PC)+A**，其中A是相对于当前指令地址的位移量，可正可负，**补码表示**。A的位数决定了操作数的寻址范围。

**优点**：操作数的地址不是固定的，它随PC值的变化而变化，且与指令之间总是相差一个固定值，因此**便于程序的浮动**。**相对寻址广泛利用于转移指令**。

**【注】**对于转移指令JMP A，当CPU从存储器中取出一个字节时，会自动执行(PC)+1->PC。若转移指令的地址为X，且占2B，在取出该指令后，PC的值会自增2，即(PC) = X + 2，这样在执行完该指令后，会自动跳转到X+2+A的地址继续执行。

<img src="./组成原理/4.2.2-6.png" alt="4.2.2-6" style="zoom:80%;" />

8. **基址寻址**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2014-17</font>

&emsp;&emsp;基址寻址是将CPU中的**基址寄存器(BR)**的内容加上指令格式中的形式地址A而形成操作数的有效地址。即**EA = (BR) + A**。其中基值寄存器既可以采用专用寄存器，又可以采用通用寄存器。

**优点**：可扩大寻址范围(**基址寄存器的位数大于形式地址A的位数**)，用户可以不用考虑自己的程序存于主存的哪个空间区域，有利于**多道程序的设计**，可用于**编制浮动程序**。

**缺点**：偏移量(形式地址A)的位数较短。

**【注1】**基址寄存器是**面向操作系统**的，其内容由操作系统或管理员确定，主要用于**解决程序逻辑空间与存储器的物理空间的无关性**。

**【注2】在程序执行的过程中，基址寄存器的内容不变(作为基地址)，形式地址可变(作为偏移量)**。采用通用寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍然是由操作系统确定。

<img src="./组成原理/4.2.2-7.png" alt="4.2.2-7" style="zoom:80%;" />

9. **变址寻址**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2013-17,2016-17,2017-15</font>

&emsp;&emsp;变址寻址是指有效地址EA等于指令字中的形式地址A与**变址寄存器(IX)**的内容之和，即                 **EA = (IX) + A**。其中IX可为专业寄存器，也可以是通用寄存器。

**优点**：可扩大寻址范围(变址寄存器的位数大于形式地址A的位数)，**常用于数组处理**，可设定A为数组的首地址。**特别适合编制循环程序**。偏移量(变址寄存器IX)的位数足够以表示整个存储空间。

**【注】**变址寄存器是**面向用户的**，在程序执行的过程中，**变址寄存器可由用户改变(作为偏移量)，形式地址A不变(作为基地址)**。

<img src="./组成原理/4.2.2-8.png" alt="4.2.2-8" style="zoom:80%;" />

10. **堆栈寄存器**

&emsp;&emsp;堆栈是存储器(或专用寄存器组)中一块特定的、按后进先出(LIFO)原则管理的存储区，该存储区中被读/写单元的地址是用一个特定的寄存器给出的，该寄存器为**堆栈指针(SP)**。堆栈可分为**硬堆栈**和**软堆栈**两种。

&emsp;&emsp;**寄存器堆栈又称为硬堆栈**。寄存器堆栈的成本比较高，不适合做大容量的堆栈；而从**主存划分一段区域做堆栈**是最常用的方法，这种堆栈称为**软堆栈**。

**【注】**采用堆栈结构的计算机系统中，**大部分指令表面上都表现为无操作数指令的形式**，因为操作数地址都隐含使用了SP。通常情况下，在读/写堆栈中的一个单元的前后都伴有自动完成对SP内容的增量或减量操作。

<img src="./组成原理/4.2.2-9.png" alt="4.2.2-9" style="zoom:80%;" />



### 4.3 CISC和RISC的基本概念

#### 4.3.2 精简指令系统计算机(RISC)

<img src="./组成原理/4-3-1.png" alt="4-3-1" style="zoom:80%;" />

#### 4.3.3 CISC和RISC的比较

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-17</font>

<img src="./组成原理/4-3-2.png" alt="4-3-2" style="zoom:80%;" />



## 第5章 中央处理器

### 5.1 CPU的功能和基本结构

#### 5.1.1 CPU的功能

- **指令控制**：完成取指令、分析指令和执行指令的操作，即程序的顺序控制。
- **操作控制**：CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指定的要求进行动作。
- **时间控制**：为每条指令按时间顺序提供应有的控制信号。
- **数据加工**：对数据进行算术和逻辑运算。
- **中断处理**：对计算机运行过程中出现的异常情况和特殊请求进行处理。

#### 5.1.2 CPU的基本结构部

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2010-18,2011-17,2016-18</font>

<img src="./组成原理/5.1.2-1.png" alt="5.1.2-1" style="zoom:90%;" />

1. **运算器**

&emsp;&emsp;运算器接收从控制器送来的命令并执行相应的动作，对数据进行加工和处理，它是对数据进行加工处理的中心。

**1）算术逻辑单元(ALU)**：主要功能是进行算术/逻辑运算。

**2）暂存寄存器**：用于暂存从主存读来的数据，该数据不能存放在通用寄存器中，否则会破坏其原有的内容。**暂时寄存器对应用程序员是透明的**。

**3）累加寄存器(ACC)**：它是一个通用寄存器，用于暂时存放ALU运算的结果信息，可以作为加法运算的一个输入端。

**4）通用寄存器组**：如AX、BX、CX、DX、SP等，用于存放操作数(包括源操作、目的操作数及中间结果)和各种地址信息。SP是堆栈指针，用于指示栈顶的地址。

**5）程序状态寄存器(PSW)**：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如**溢出标志(OF)、符号标志(SF)、零标志(ZF)、进位标志(CF)**等。PSW中的这些位参与并决定微操作的形成。

**6）移位器**：对操作数或运算结果进行移位运算。

**7）计数器(CT)**：控制乘除运算的操作步数。

2. **控制器**

&emsp;&emsp;控制器是整个系统的指挥中枢，在控制器的控制下，使运算器、存储器和输入/输出设备等功能部件构成一个有机的整体，根据指令的要求指挥全机协调工作。

&emsp;&emsp;控制器的基本功能是执行指令，**每条指令的执行是由控制器发出的一组微操作实现的**。

**1）程序计数器(PC)**：用于指出下一条指令在主存中的存放地址。CPU根据PC的内容去主存中取指令。因程序中指令通常是顺序执行的，所以**PC有自增功能**。

**2）指令寄存器(IR)**：用于保存当前正在执行的那条指令。

**3）指令译码器**：仅对操作字段进行译码，向控制器提供特定的操作信号。

**4）存储器地址寄存器(MAR)**：用于存放所要访问的主存单元的地址。

**5）存储器数据寄存器(MDR)**：用于存放向主存写入的信息或从主存中读出信息。

**6）时序系统**：用于产生各种时序信号，它们都由统一时钟(CLOCK)分频得到。

**7）微操作信号发生器**：根据IR的内容(指令)、PSW的内容(状态信息)及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有**组合逻辑**和**存储逻辑**两种。

**【注1】**CPU内部寄存器分为两类：一类是**用户可见的寄存器**，可对这类寄存器编程，如**通用寄存器**、**程序状态寄存器(PSW)**，**程序计数器(PC)**；另一类是**用户不可见的寄存器**，对用户是透明的，不可对这类寄存器进行编程，如**存储器地址寄存器(MAR)**、**存储器数据寄存器(MDR)**、**指令寄存器(IR)**。

**【注2】程序计数器**的位数取决于**存储器的字数**，它与MAR的位数是一样的；**指令寄存器**的位数取决于**指令字长**；**通用寄存器**的位数取决于**机器字长**。

**【注3】**所谓的n位CPU中，n是指**数据总线线数**。



### 5.2 指令的执行过程

#### 5.2.1 指令周期

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-11,2011-19</font>

1. **概念**

&emsp;&emsp;CPU从主存中每取出并执行一条指令所需的全部时间称为**指令周期**，即CPU完成一条指令的时间。

&emsp;&emsp;指令周期常用若干个**机器周期**来表示，一个机器周期又包含若干**时钟周期**(也称为**节拍**或**T周期**，它是**CPU操作的最基本(最小)单位**)。每个指令周期内的机器周期数可以不等，每个机器周期内的节拍数也可以不等。
$$
\begin{align}
机器周期 &= 主存周期 \\
时钟周期 &= 计算机主频的倒数 \\
计算机主频 &= 1s时钟周期数 \\
存取周期 &= 存储器进行两次独立的存储器操作(连续两次读或写)所需的最小间隔时间
\end{align}
$$



<img src="./组成原理/5.2-1.png" alt="5.2-1" style="zoom:80%;" />

<img src="./组成原理/5.2.1-2.png" alt="5.2.1-2" style="zoom:80%;" />

**【注1】**中断周期中的进栈操作是将SP减1，这和传统意义上的进栈操作相反，原因是计算机的堆栈都是向低地址增加，所以进栈操作是减1而不是加1。

**【注2】**CPU响应中断的时间是一条指令执行结束

**【注3】**指令字长一般等于存储字长的整数倍，若等于存储字长的2倍，则需要访问两次主存，取指周期等于机器周期的2倍。



### 5.3 数据通路的功能和基本结构

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2009-44,2015-43</font>

#### 5.3.1 数据通路的功能

&emsp;&emsp;**数据在功能部件之间传送的路径称为数据通路**。运算器与各寄存器之间的传送路径就是中央处理器的内部数据通路。

&emsp;&emsp;数据通路描述了信息从什么地方开始，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器，这些都要加以控制。

&emsp;&emsp;建立数据通路的任务是由“操作控制部件”来完成的。**数据通路的功能是实现CPU内部的运算器与寄存器及寄存器之间的数据交换**。



#### 5.3.2 数据通路的基本结构

数据通路的基本结构主要有以下几种：

**1）CPU内部单总线方式**：将所有**寄存器的输入端和输出端都连接到一条公共通路上**，这种结构比较简单，但数据传输存在较多的冲突现象，性能比较低。连接各部件的总线只有一条，称为单总线结构；CPU中有两条或更多的总线时，构成双总线结构或多总线结构。

**2）CPU内部三总线方式**：将所有寄存器的输入端和输出端都连接到多条公共通路上，相比之下单总线中一个时钟内只允许传一个数据，因而执行效率很低，因此采用多总线方式，提高效率。

**3）专用数据通路方式**：根据指令执行过程中的数据和地址的流动方向安排连接线路，避免使用共享的总线，性能较高，但硬件量大。

<img src="./组成原理/5.3.2-1.png" alt="5.3.2-1" style="zoom:80%;" />

**【注】**内部总线是指同一部件，如CPU内部连接各个寄存器及运算部件之间的总线；系统总线是指同一台计算机系统的各部件，如CPU、内存、通道和各类I/O接口间相互连接的总线。

1. **寄存器之间的数据传送**

&emsp;&emsp;寄存器之间的数据传送可通过CPU内部总线完成，如图5.7，某寄存器分别由AXout和AXin控制。这里以PC寄存器为例，把PC内容送至MAR，实现传送操作的流程及控制信号为：

<img src="./组成原理/5.3.2-2.png" alt="5.3.2-2" style="zoom:80%;" />

2. **主存与CPU之间的数据传送**

&emsp;&emsp;主存与CPU之间的数据传送也要借助CPU内部总线完成。现以CPU从主存读取指令为例说明数据在数据通路中的传送过程。实现传送操作的流程及控制信号为：

<img src="./组成原理/5.3.2-3.png" alt="5.3.2-3" style="zoom:80%;" />

3. **执行算术或逻辑运算**

&emsp;&emsp;执行算术或逻辑操作时，由于ALU本身是没有内部存储功能的组合电路，因此如果要执行加法运算，相加的两个数必须在ALU的两端同时有效。图5.7中的**暂存器Y**用于该目的。**先将一个操作数经CPU内部总线送入暂存器Y保存，Y的内容在ALU的左输入端始终有效，再将另一个操作数经总线直接送到ALU的右输入端。这样两个操作数都送入了ALU，结果暂时存在暂存器Z中**。

<img src="./组成原理/5.3.2-4.png" alt="5.3.2-4" style="zoom:80%;" />



### 5.4 控制器的功能和工作原理

#### 5.4.1 控制器的结构和功能

<img src="./组成原理/5.4.1-1.png" alt="5.4.1-1" style="zoom:80%;" />

控制器包括**指令寄存器IR**和**程序计数器PC**，它是计算机系统的指挥中心，控制器主要功能有：

1）从主存取出一条指令，并指出下一条指令在主存中的位置。

2）对指令进行译码或测试，产生相应的操作控制信息，以便启动规定的动作。

3）指挥控制CPU、主存、输入和输出设备之间的数据流动方向。

#### 5.4.2 硬布线控制器

1. **硬布线控制单元图**

&emsp;&emsp;指令的操作码是决定控制单元发出不同操作命令(控制信号)的关键。CU的输入信号如下：

1）经指令译码器产生的指令信息。

2）时序系统产生的机器周期信号和节拍信号。

3）来自执行单元的反馈信息即标志。

<img src="./组成原理/5.4.2-1.png" alt="5.4.2-1" style="zoom:80%;" />

2. **硬布线控制器的时序系统及微操作**<img src="./组成原理/5.4.2-2.png" alt="5.4.2-2" style="zoom:80%;" /><img src="./组成原理/5.4.2-3.png" alt="5.4.2-3" style="zoom:80%;" />

3. **CPU的控制方式**

   1）同步控制方式	2）异步控制方式	3）联合控制方式



#### 5.4.3 微程序控制器

&emsp;&emsp;微程序设计思想是将每条机器指令编写成一个微程序，每个微程序包含若干个微指令，每个微指令对应一个或几个微操作命令。目前，**大多数计算机都采用微程序设计技术**。

1. **微程序控制的基本概念**

1）**微命令**和**微操作**：一条机器指令可分解成一个微操作系列，这些**微操作是计算机中最基本的、不可再分解的操作**。在微程序控制的计算机中，将**控制部件向执行部件发出各种控制命令称为微命令**，它是构成控制序列的最小单位。**微命令是微操作的控制信号，微操作是微命令的执行过程**。

**【注1】**在组合逻辑控制器中也有微命令和微操作两个概念，它们并非是微程序控制器专有的。

**【注2】**一条指令对应一个微程序，因此一个微程序对应一个指令周期

2）**微指令**与**微周期**：微指令是若干微命令的集合。存放微程序指令的控制存储器的单元地址称为微地址。微指令通常至少包含两大部分信息：

​	① **操作控制字段**：又称为微操作码字段，用于产生某一步操作所需的各种操作控制信号。

​	② **顺序控制字段**：又称微地址码字段，用于控制产生下一条要执行的微指令地址。

3）**主存储器**与**控制存储器**：主存储器用于存放**程序和数据**，在CPU外部，用**RAM和ROM**实现；控制存储器(CM)用于存放**微程序**，在CPU内部，用**ROM**实现。主存储器按地址访问，控制存储器按微指令的地址访问。<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2017-18</font>

4）**程序**与**微程序**：程序是指令的有序集合，用于完成特定的功能；微程序是微指令的有序集合，**一条指令的功能由一段微程序来实现**。

**【注1】微程序是不面向用户的**，它是由计算机设计者事先编制好并存放在控制存储器中的。程序是面向用户的，是由软件设计人员事先编制好放在主存或辅存的。

**【注2】**在微程序控制器中，形成微程序入口地址的是机器指令的操作码字段。

- **注意区分的几个寄存器**

  ① **地址寄存器(MAR)**：用于存放主存的读/写地址。

  ② **微指令寄存器(CMAR)**：用于存放控制存储器的读/写指令的地址。

  ③ **指令寄存器(IR)**：用于存放从主存中读出的指令。

  ④ **微指令寄存器(CMDR)**：用于存放从控制存储器中取出的微指令。



2. **微程序控制器的组成和工作过程**

**（1）微程序控制器的基本结构**

​	① **控制存储器**：它是微程序控制器的核心部件，用于存放各指令对应的微程序。

​	② **微指令寄存器(CMDR)**：用于存放从CM中取出的微指令，它的位数同微指令字长相等。

​	③ **微地址形成部件**：用于产生初始微地址和后继微地址，以保证微指令的连续执行。

​	④ **微地址寄存器(CMAR)**：接收微地址形成部件送来的微地址，为在CM中读取微指令做准备。

<img src="./组成原理/5.4.3-1.png" alt="5.4.3-1" style="zoom:80%;" />

**（3）微程序和机器指令**

&emsp;&emsp;通常，一条机器指令对应一个微程序。**由于任何一条机器指令的取指令操作都是相同的，因此可以将取指令操作的微命令统一编成一个微程序**，这个微程序只负责将指令从主存单元中取出并送至寄存器。

**【注1】**若指令系统中具有**n**种机器指令，则控制寄存器中的微程序数至少是**n+1(1为公共取指微操作)**。

**【注2】**取指令是控制器所固有的，不需要在操作码控制下进行。



3. **微指令的编码方式**

**（1）直接编码(直接控制)方式**

&emsp;&emsp;直接编码法无须进行译码，微指令的微命令字段中每位都代表一个微命令。设计微指令时，选用或不选用某个微命令，只要将表示该微命令对应位设置成1或0即可。

**优点**：简单、直观、执行速度快，操作并行性好。

**缺点**：微指令字长过长，**n个微命令就要求微指令的操作字段有n位**。

<img src="./组成原理/5.4.3-2.png" alt="5.4.3-2" style="zoom:80%;" />

**（2）字段直接编码方式**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2012-18</font>

&emsp;&emsp;将微指令的微命令字段分成若干小字段，把**互斥性微命令组合在同一字段中**，把**相容性微命令组合在不同字段中**，每个字段独立编码。

- **微命令字段的分段原则**
  - 互斥性命令分别在同一段中，相容性微命令分别在不同段中
  - 每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间
  - 一般每个小段还要留出一个状态，表示本字段不发出任何微命令。因此，**当某字段的长度为3时，最多只能表示7个互斥的微命令**，**通常用000表示不操作**。

**优点**：可以缩短微指令字长

**缺点**：因为要通过译码电路后再发出微命令，因此执行速度慢

<img src="./组成原理/5.4.3-3.png" alt="5.4.3-3" style="zoom:80%;" />

**（3）字段间接编码方式**

&emsp;&emsp;一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出微命令，故称为字段间接编码，又称隐式编码。



4. **微指令的地址形成方式**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2014-18</font>

后继地址的形成主要有以下两大基本类型：

1）**直接由微指令的下地址段给出(断定方式)**

2）**根据机器指令的操作码形成**

微指令序列地址形成方式还有以下几种：<img src="./组成原理/5.4.3-4.png" alt="5.4.3-4" style="zoom: 80%;" />



5. **微指令的格式**

**1）水平型微指令**：从编码上看。直接编码、字段直接编码、字段间接编码和混合编码都属于水平型微指令。指令字中的一位对应一个控制信号，有输出时为1，否则为0。**一条水平型指令定义并执行几种并行的基本操作**。

<img src="./组成原理/5.4.3-5.png" alt="5.4.3-5" style="zoom:80%;" />

**优点**：微程序短，执行速度快

**缺点**：微指令长，编写微程序比较麻烦

**2）垂直型微指令**：垂直型微指令的特点是采用类似机器指令操作码方式，在微指令中设置操作码字段，采用微操作码编译法，由微操作码规定微指令的功能。**一条垂直型微指令只能定义并执行一种基本操作**。

<img src="./组成原理/5.4.3-6.png" alt="5.4.3-6" style="zoom: 80%;" />

**优点**：微指令短、简单、规整，便于编写微程序。

**缺点**：微程序长，执行速度慢，工作效率低。

**3）混合型微指令**：在垂直型的基础上增加一些不太复杂的并行操作。微指令较短，仍便于编写；微程序也不长，执行速度快。

- **水平微指令 VS 垂直型微指令**

<img src="./组成原理/5.4.3-7.png" alt="5.4.3-7" style="zoom:80%;" />



#### 5.4.4 微程序 VS 硬布线

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-19</font>

<img src="./组成原理/5.4-1.png" style="zoom:75%;" />



### 5.5 指令流水线

#### 5.5.1 指令流水线的基本概念

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-18，2011-18</font>

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2012-44.2014-44</font>

3. **流水线方式的特点**

（1）把一个任务(一条指令或一个操作)分解为**几个有联系的子任务**，每个子任务由一个专门的功能部件来执行，并依靠多个功能部件并行工作来缩短执行时间。

（2）流水线每个功能部件后面都要有一个**缓冲寄存器**，或称为锁存器，其作用是保存流水段的执行结果，供给下一流水段使用。

（3）流水线中各个**功能段的时间应尽量相等**，否则会引起堵塞、断流。

（4）只有连续不断地提供同一种任务时才能发挥流水线的效率，所以流水线的中处理的必须是**连续任务**。

（5）流水线需要有**装入时间**和**排空时间**。装入时间是指第一个任务进入流水线到输出流水线的时间。排空时间是指最后一个任务进入流水线到输出流水线的时间。





#### 5.5.3 影响流水线的因素

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2010-19</font>

1. **结构相关(资源冲突)**

由于**多条指令在同一时刻争用同一资源**形成的冲突称为结构相关，有以下解决方案：

（1）前一指令访存时，使后一条相关指令(以及其后续指令)暂停一个时钟周期。

（2）单独设置数据存储器和指令存储器，使两项操作各自在不同的存储器中进行，这属于资源重配置。



2. **数据相关(数据冲突)**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2016-19</font>

&emsp;&emsp;数据相关是指在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况，此时这两条指令记为数据相关。解决方法如下

（1）**暂停一个周期或多个周期**，直到数据相关问题消失后再执行。可分为**硬件阻塞(stall)**和**软件插入“NOP”指令**两种方法。

（2）**设置相关专用通路**，即不等前一条指令把结果写回寄存器组，下一条指令也不再读寄存器组，而直接把前一条指令ALU计算结果作为自己输入数据开始计算过程，使本来需要暂停的操作变得可以继续执行，这也称为**数据旁路技术**。

（3）**调整指令顺序**。



3. **控制相关(控制冲突、控制冒险)**

当流水线遇到**转移指令**和**其它改变PC值的指令**而造成断流时，会引起控制相关。解决方法如下：

（1）**对转移指令进行分支预测，尽早生成转移目标地址**。分支预测分**简单(静态)预测**和**动态预测**。静态预测总是预测条件不满足，即继续执行分支指令的后续指令。动态预测根据程序执行的历史情况，进行动态调整，有较高的预测准确率。

（2）预测转移成功和不转移成功两个控制流方向上的目标指令。

（3）加快和提前形成条件码。

（4）提高转移方向的猜准率。



#### 5.5.4 流水线的性能指标

1. **流水线的吞吐率**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2013-18</font>

&emsp;&emsp;在指令级流水线中，吞吐率是指在单位时间内流水线所完成的任务数量，或输出结果的数量，计算流水线吞吐率(TP)的最基本的公式为
$$
TP= \frac{n}{T_k}
$$
式子中，$n$是任务数，$T_k$是处理完$n$个任务所用的时间。

- **例子**

&emsp;&emsp;对于一条$k$段流水线能够在$k+n-1$个时钟周期内完成$n$个任务。设时钟周期为$\Delta t$，则流水线的吞吐率为
$$
TP = \frac{n}{(k+n-1) \Delta t}
$$
当$n\rightarrow \infty$时，得到最大的吞吞吐率为$TP_\max = 1/\Delta t$

2. **流水线的加速比**

&emsp;&emsp;完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间比，称为流水线的加速比。

&emsp;&emsp;设$T_0$表示不使用流水线时的执行时间，即顺序执行所用的时间；$T_k$表示使用流水线时的执行时间，则计算流水线加速比$S$为
$$
S = \frac{T_0}{T_k}
$$
若流水线各执行的时间都相等，则一条k段流水线完成$n$个任务的加速比为
$$
S = \frac{kn \Delta t}{(k+n-1) \Delta t} = \frac{kn}{k+n-1}
$$
若连续输入的任务数$n \rightarrow \infty$，最大加速比为$S_\max = k$。

3. **流水线的效率**

$$
E = \frac{n个任务占用的时空区有效面积}{n个任务所用的时间与k个流水线段所围成的时空区总面积}=\frac{T_0}{T_k}=\frac{nk \Delta t}{(n+k-1)k \Delta t}
$$

若连续输入的任务数$n \rightarrow \infty$，最大流水线效率$E_\max = 1$。



#### 5.5.5 超标量流水线的基本概念

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2017-17</font>

1. **超标量流水线技术**

&emsp;&emsp;**每个时钟周期内可并发多条独立指令**，即以并行操作方式将两条或多条指令编译并执行，为此**需配置多个功能部件**。

&emsp;&emsp;超标量计算机不能调整指令的执行顺序，因此通过**编译优化技术**，把可并行执行的指令搭配起来，挖掘更多的指令并行性，如图：

<img src="./组成原理/5.5.5-1.png" alt="5.5.5-1" style="zoom:80%;" />

2. **超流水线技术**

&emsp;&emsp;在一个时钟周期内再分段，**在一个时钟周期内一个功能部件使用多次**。不能调整指令的执行顺序，**靠编译程序解决优化问题**。

<img src="./组成原理/5.5.5-2.png" alt="5.5.5-2" style="zoom:80%;" />

3. **超长指令字**

&emsp;&emsp;由编译程序挖掘出指令周期潜在的并行性，**将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字(可达几百位)**，为此需要**采用多个处理部件**。



## 第6章 总线

### 6.1 总线概述

#### 6.1.1 总线基本概念

1. **总线的定义**

总线是一组能为多个部件分时共享的公共信息传送线路。**分时**和**共享**是总线的两个特征。

- **分时**：同一时刻只允许有一个部件向总线发送信息。
- **共享**：总线上可以挂接多个部件，各个部件之间相互交换的信息都可以通过这组线路分时共享。

2. **总线设备**

- **主设备**：总线的主设备是指获得总线控制权的设备。
- **从设备**：总线的从设备是指被主设备访问的设备，它只能响应从主设备发来的各种总线命令。

3. **总线特性**

- **机械特征**：尺寸、形状
- **电气特性**：传输方向和有效的电平范围
- **功能特性**：每根传输线的功能
- **时间特性**：信号和时序的关系

4. **总线的猝发(突发)式传输方式**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2014-20</font>

&emsp;&emsp;**猝发(突发)传送**是在一个总线周期中，可以传输多个存储地址连续的数据，即**一次传输一个地址和一批连续的数据**。

【注】**并行传输 VS 串行传输 VS 同步传输**

&emsp;&emsp;并行传输是在传输中**有多个数据位同时在设备之间进行的传输**；串行传输是指数据的二进制代码在一条物理信道上**以位为单位按时间顺序逐位传输的方式**；同步传输是指传输过程**由统一的时钟控制**。



#### 6.1.2 总线的分类

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2011-20</font>

1. **片内总线**

&emsp;&emsp;片内总线是芯片内部的总线，它是CPU芯片内部**寄存器与寄存器**之间、**寄存器与ALU**之间的公共连接线。

2. **系统总线**

&emsp;&emsp;系统总线是**计算机系统内部各功能部件(CPU、主存、I/O)接口之间相互连接的总线**。按系统传输信息的内容不同，又可分为3类，**数据总线**、**地址总线**和**控制总线**。

**1）数据总线**：用来传输各功能部件之间的数据信息，它是**双向**传输总线，其**位数与机器字长、存储字长有关**。

**【注】**数据总线上可以传输**指令**、**操作数**、**中断类型号**等。

**2）地址总线**：用来指出数据总线上的源数据或目的数据所在的主存单元或I/O端口的地址，它是**单向**传输总线，**地址总线的位数与主存地址空间的大小有关**。

**3）控制总线**：用来控制信息，包括CPU发出的控制命令和主存(或外设)返回CPU的反馈信息。

&emsp;&emsp;注意区分**数据通路**和**数据总线**：各个功能部件通过数据总线连接形成的数据传输路径称为数据通路。数据通路表示的是数据流的路径，而数据总线是承载媒体。

3. **通信总线**

&emsp;&emsp;通信总线是在**计算机系统之间**或**计算机系统与其他系统(如远程通信设备、测试设备)之间**传送信息的总线，**通信总线也称为外部设备**。



#### 6.1.3 系统总线的结构

1. **单总线结构**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2016-20</font>

&emsp;&emsp;单总线结构将CPU、主存、I/O设备(通过I/O接口)都挂在一组总线上，运行I/O设备之间、I/O设备与主存之间直接交换信息。CPU与主存、CPU与外设之间可直接进行信息交换，而无须经过中间设备的干预。

- **优点：**结构简单，成本低，易于接入新的设备
- **缺点：**带宽低、负载重，多个部件只能争用唯一的总线，而**不支持并发传送操作**

<img src="./组成原理/6.1.3-1.png" alt="6.1.3-1" style="zoom:80%;" />

2. **双总线结构**

&emsp;&emsp;双总线有两头总线：一条是**主存总线，用于在CPU、主存和通道之间**传送数据；另一条是**I/O总线**，用于在**多个外部设备与通道之间**传送数据。

**【注】**总线之间须用**桥接器**相连

- **优点：**将低速I/O设备从单总线上分离出来，实现了存储器总线和I/O总线分离。
- **缺点：**需要增加通道等硬件设备。

<img src="./组成原理/6.1.3-2.png" alt="6.1.3-2" style="zoom:80%;" />

3. **三总线结构**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2017-20</font>

&emsp;&emsp;三总线结构是在计算机系统各部件之间采用3条各种独立的总线来构成信息通道，这3条总线分别为**主存总线**、**I/O总线**和**直接内存访问(DMA)总线**。

&emsp;&emsp;**主存总线**用于在**CPU和内存之间**传送地址、数据和控制信息。

&emsp;&emsp;**I/O总线**用于在**CPU和各外设之间**通信。

&emsp;&emsp;**DMA总线**用于在**内存和高速外设之间**直接传送数据。

- **优点：**提高了I/O设备的性能，使其更快地响应命令，提高系统吞吐量
- **缺点：**系统工作效率较低

<img src="./组成原理/6.1.3-3.png" alt="6.1.3-3" style="zoom:80%;" />



#### 6.1.4 总线的性能指标

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-20,2012-19.2014-19,2016-21</font>

（1）**总线的传输周期**：指一次总线操作所需的时间(包括**申请阶段**、**寻址阶段**、**传输阶段**和**结束阶段**)，简称**总线周期**。总线传输周期通常由若干**总线时钟周期**构成。

（2）**总线时钟周期**：即**机器的时钟周期**。机器有一个统一的时钟，以控制整个计算机各个部件，总线也要受此时钟的控制。

（3）**总线的工作频率**：总线上各种操作的频率，为**总线周期的倒数**。实际上指1s内传送几次数据。若
$$
总线周期=N个时钟周期，则总线的工作频率=时钟频率/N
$$
（4）**总线的时钟频率**：即**机器的时钟频率**，它为**时钟周期的倒数**。

（5）**总线宽度**：又称**总线位宽**，它是总线上同时能传输的数据位数，通常指**数据总线的根数**，如32根称为32位总线。

（6）**总线的带宽**：可以理解为**总线的数据传输率**，即单位时间内总线上可以传输数据的位数，通常用每秒传送信息的字节数来衡量，单位可用**字节/秒(B/s)**。
$$
总线带宽=总线工作频率 \times (总线宽度/8)
$$
（7）**总线复用**：总线复用指一种信号线在不同的时间传输不同的信息，因此可以使用较少的线传输更多的信息，从而节省空间和成本。

（8）**信号线数**：**地址总线**、**数据总线**和**控制总线**3种总线数的总和称为信号线数。其中，总线的最主要性能指标为**总线宽度**、**总线(工作)频率**、**总线带宽**。

**【注】**总线**突发传输方式**传输数据的时间：$T=数据传输时间+地址传输时间$



### 6.2 总线总裁

&emsp;&emsp;为**解决多个主设备同时竞争总线控制权的问题**，应当采取总线总裁部件，以某种方式选择一个主设备优先获得总线控制权。只有获得了总线控制权的设备，才能开始传输数据。

#### 6.2.1 集中仲裁方式

&emsp;&emsp;总线控制逻辑基本上集中于一个设备(如CPU)中。将所有的总线请求集中起来，利用一个特定的裁决算法进行裁决，称为集中仲裁方式。

1. **链式查询方式**

- **原理**

<img src="./组成原理/6.2.1-1.png" alt="6.2.1-1" style="zoom:80%;" />

在链式查询中，**部件离总线控制器越近，其优先级越高；部件离总线控制部件越远，其优先级越低**。

<img src="./组成原理/6.2.1-4.png" alt="6.2.1-4" style="zoom:80%;" />

- **优点 VS 缺点**
  - **优点**：链式查询方式优先级固定。此外，只需要少几根控制线就能按一定优先次序实现总线控制，结构简单，扩充容易。
  - **缺点**：对硬件电路的故障敏感，且优先级不能改变。当优先级高的部件频繁请求使用总线时，会使优先级低的部件长期不能使用总线。

2. **计数器定时查询方式**

- **原理**

<img src="./组成原理/6.2.1-2.png" alt="6.2.1-2" style="zoom:80%;" />

<img src="./组成原理/6.2.1-3.png" alt="6.2.1-3" style="zoom:80%;" />

<img src="./组成原理/6.2.1-5.png" alt="6.2.1-5" style="zoom:80%;" />

- 优点 VS 缺点**
  - **优点**：计数可从“0”开始，此时一旦设备的优先次序被固定，设备的优先级就按0、1、2、...、n顺序**降序排序**，且固定不变；计数也可以从上一次的终点开始，即采用一种循环方法，此时设备使用总线的优先级相等；计数器的初值还可以由用户设置，故优先次序可以改变，且**这种方式对电路的故障没有链式查询方式的敏感**。
  - **缺点**：增加了控制线数(若设备有n个，则大致需要$\lceil \log_2 n \rceil +2$条控制线)，控制也比链式查询的复杂。

3. **独立请求方式**

- **原理**

<img src="./组成原理/6.2.1-6.png" alt="6.2.1-6" style="zoom:80%;" />

<img src="./组成原理/6.2.1-7.png" alt="6.2.1-7" style="zoom:80%;" />

- **优点 VS 缺点**
  - **优点**：响应速度快，总线允许信号BG直接从控制器发送到有关设备，而不必在设备间传递或查询，而且对优先次序的控制相当灵活。
  - **缺点**：控制线数量多(设备有$n$个，需要$2n+1$条控制线，其中加的那条控制线为BS线，其基作用是**让设备向总线控制部件反馈已使用完总线**)，总线控制逻辑更加复杂。

<img src="./组成原理/6.2.1-8.png" alt="6.2.1-8" style="zoom:80%;" />



#### 6.2.2 分布仲裁方式

<img src="./组成原理/6.2.2-1.png" alt="6.2.2-1" style="zoom:80%;" />



### 6.3 总线操作和定时

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2015-19</font>

&emsp;&emsp;总线定时是指在**总线双方交换数据的过程中需要时间上配合关系的控制**，这种控制称为总线定时，其实质是一种协议或规则，主要有同步和异步两种基本定时方式。

#### 6.3.1 总线传输的4个阶段

一个总线周期可分为以下4个阶段：<img src="./组成原理/6.3.1-1.png" alt="6.3.1-1" style="zoom:80%;" />

#### 6.3.2 同步定时方式

&emsp;&emsp;所谓同步定时方式，是指**系统采用一个统一的时钟信号来协调发送和接收双方的传送和定时关系**。时钟产生相等的时间间隔，**每个间隔构成一个总线周期**。在一个总线周期中，发送方和接收方可以进行一次数据传送。因为采用统一的时钟，每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线的传送周期开始。

- **优点 VS 缺点**

<img src="./组成原理/6.3.2-1.png" alt="6.3.2-1" style="zoom:80%;" />

**【注】**同步通信适用于**总线长度较短**及**总线所接部件的存取时间比较接近**的系统。



#### 6.3.3 异步定时方式

&emsp;&emsp;在异步定时方式中，**没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制**。通常，**把交换信息的两个部件或设备分为主设备和从设备**，主设备提出交换信息的“请求”信号，经过接口传送到从设备；从设备接到主设备的请求后，通过接口向主设备发出“回答”信号。

**【注】**还有一种是半同步方式，握手信号的采样是由同步时钟控制。

- **优点**：总线周期长度不变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自适应时间的配合。
- **缺点**：比同步控制方式稍微**复杂**一些，**速度比同步方式慢**。

&emsp;&emsp;根据“请求”和“回答”信号的撤销是否互锁，异步又分为以下3种类型。

- **不互锁方式**：主设备发出“请求”信号后，不必等到接到从设备的“回答“信号，而是经过一段时间便撤销“请求”信号。而从设备在接到”请求“信号后，发出”回答“信号，并经过一段时间后自动撤销”回答“信号。双方不存在互锁的关系。
- **半互锁方式**：主设备发出“请求”信号后，必须在接收从设备的“回答”信号后，才撤销“请求”信号，有互锁的关系。而从设备在接到“请求”信号后，发出“回答”信号，但不必等待获知主设备的“请求”信号已经撤销，而是隔一段时间后自动撤销“回答”信号，不存在互锁关系。
- **全互锁方式**：主设备发出“请求”信号后，必须在从设备“回答”后才能撤销；从设备发出“回答”信号后，必须在获知主设备“请求”信号已撤销后，再撤销其“回答”信号。双方存在互锁方式。

**【注】**全互锁协议的速度最慢，不互锁协议的可靠性最差。

<img src="./组成原理/6.3.3-1.png" alt="6.3.3-1" style="zoom:80%;" />





### 6.4 总线标准

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2010-20,2012-20,2013-19</font>

#### 6.4.1 常见的总线标准

&emsp;&emsp;总线的标准有**ISA、EISA、VESA、PCI、PCI-Express、AGP、RS-232C、USB**等。它们主要的区别是总线宽度、带宽、时钟频率、寻址能力、是否支持突发传送等。

<img src="./组成原理/6.4.1-1.png" alt="6.4.1-1" style="zoom:80%;" />

<img src="./组成原理/6.4.1-2.png" alt="6.4.1-2" style="zoom:80%;" />

**【注】**局部总线：VESA、PCI、AGP。高速设备采用局部总线，可以节省系统的总带宽。



## 第7章 输入/输出系统

### 7.1 I/O系统基本概念

#### 7.1.2 I/O控制方式

<img src="./组成原理/7.1.2-1.png" alt="7.1.2-1" style="zoom:80%;" />

方式1）和方式2）主要用于数据传输效率低的外部设备，方式3）和方式4）主要用于数据传输率高的设备。



### 7.2 外部设备

&emsp;&emsp;外部设备也称为外围设备，是除主机外的能直接或间接与计算机交换信息的装置。最基本的外部设备主要有**键盘、鼠标、显示器、打印机、磁盘存储器和光盘存储器**等。

#### 7.2.1 输入设备

1. **键盘**

&emsp;&emsp;键盘是最常用的输入设备，通过它可以=发出命令或输入数据。

&emsp;&emsp;键盘输入信息可分为3个步骤：① 查出按下哪个键；② 将该键翻译成能被主机接收的编码，如ASCII码；③ 将编码传送给主机。

2. **鼠标**

&emsp;&emsp;鼠标是常用的定位输入设备，它分**机械式**和**光电式**两种。

&emsp;&emsp;工作原理：鼠标在平面上移动时，其底部传感器把运动的方向和距离检测出来，从而控制光标做相应的运动。

#### 7.2.2 输出设备

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2010-22</font>

1. **显示器**

- **分类**

**（1）按显示设备所用的显示器件分类**：阴极射线管(CRT)显示器、液晶显示器(LCD)、发光二极管(LED)显示器等。

**（2）按所显示的信息内容分类**：字符显示器、图形显示器、图像显示器。

**（3）按扫描方式不同**：光栅扫描显示器、随机扫描显示器。

- **屏幕大小**：以对角线的长度表示，常用的有12~29英寸等。
- **分辨率**：所能表示的像素个数，屏幕上的每个光点就是一个像素，以宽和高的像素乘积表示，如800&times;600、1027&times;768等。
- **灰度级**：灰度级是指黑白显示器中所显示的像素点的亮暗差别，在彩色显示器中则表现为颜色的不同，**灰度级越多，图像的层次越清楚、逼真**，典型的有8位(256级)、16位等。
- **刷新**：光点只能保持极短的时间就会消失，此时必须在光点消失前重新扫描显示一遍，这个过程称为刷新。
- **刷新频率**：指单位时间内扫描整个屏幕内容的次数。按照**人的视觉生理，刷新频率大于30HZ时才不会感到闪烁**，通常显示器的刷新频率为60~120HZ。
- **显示存储器(VRAM)**：也称为刷新存储器，为了不断提高刷新图像的信号，必须把一帧图像信息存储在刷新存储器中。其**存储容量由图像分辨率和灰度级决定的**，分辨率越高，灰度级越多，刷新存储容量越大。

$$
\begin{aligned}
& VRAM容量 = 分辨率 \times 灰度级位数 \\
& VRAM带宽 = 分辨率 \times 灰度级位数 \times 帧数
\end{aligned}
$$

- **液晶(LCD)显示器 VS 发光二极管(LED)显示器**

LED显示器在亮度、功耗、可视角度和刷新速率等方面更具优势。

2. **打印机**

- **分类**

**（1）按工作原理**：打击式和非打击式打印机

**（2）按工作方式**：点阵打印机、针式打印机、喷墨式打印机、激光打印机



#### 7.2.3 外存储器





### 7.3 I/O接口

I/O接口(I/O)控制器是**主机和外设之间的交接界面**，通过接口可以实现主机和外设之间的信息交换。

#### 7.3.1 I/O接口的功能

**（1）实现主机和外设的通信联络控制**：解决主机与外设时序的配合问题，协调不同工作速度的外设和主机之间的交换信息。

**（2）进行地址译码和设备选择**：CPU送来外设的地址码后，接口必须对地址进行译码以产生设备选择信息，使主机与指定的外设交换信息。

（3）**实现数据缓冲**：CPU与外设之间的速度往往不匹配，为消除速度差异，接口必须设置数据缓冲寄存器，用于数据的暂存，避免因速度不一致而丢失数据。

（4）**信号格式的转换**：电平转换、并/串或串/并转换、模/数或数/模转换等。

（5）**传送控制命令和状态信息**：CPU要启动某一外设时，通过接口中的**命令寄存器**向外设发送启动命令；外设准备就绪时，则将“准备好”状态信息送回接口中的**状态寄存器**，并反馈给CPU。外设向CPU提出中断请求和DMA请求时，CPU也应有相应的响应信号反馈给外设。

#### 7.3.2 I/O接口的基本结构

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2012-21</font>

<img src="./组成原理/7.3.2-1.png" alt="7.3.2-1" style="zoom:85%;" />

&emsp;&emsp;CPU与外设之间的信息传递，实质上是**对接口中的某些寄存器(即端口)进行读或写**，如传送数据是对数据端口DBR进行读写操作。

- **内部接口**：内部接口与系统总线相连，实际上是**内存、CPU**相连。数据的传输方式只能是**并行传输**。
- **外部接口**：外部接口通过接口电缆与外设相连，外部接口的数据传输只能是**串行方式**。

I/O接口与CPU之间的I/O总线有**数据线**、**命令线**和**地址线**。

- **命令线**和**地址线**都是**单向传输**的，从CPU传送给I/O接口，而**I/O接口中的命令字**、**状态字**及**中断类型号**均是I/O接口发往CPU的，故只能通过**I/O总线的数据线**传输。

【注】**接口和端口是两个不同的概念**。端口是指接口电路中可以进行**读/写的寄存器**，若干端口加上相应的控制逻辑才可以组成接口。



#### 7.3.3 I/O接口的类型

从不同的角度看，I/O接口可以分为不同的类型。

1）**按数据传输方式**可分为**并行接口(一个字节或一个字的所有位同时传送)**和**串行接口(一位一位地传送)**，接口要完成数据格式的转换。

**【注】**这里所说的数据传送方式指的是**外设和接口一侧的传送方式**，而**在主机和接口一侧，数据总是并行传送的**。

2）**按主存访问I/O设备的控制方式**可分为**程序查询接口、中断接口和DMA接口**等。

3）**按功能选择的灵活性**可分为**可编程接口**和**不可编程接口**。



#### 7.3.4 I/O端口及其编址

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2014-21,2015-21,2017-21</font>

&emsp;&emsp;I/O端口是指接口电路中**可被CPU直接访问的寄存器**，主要有**数据端口、状态端口**和**控制端口**,若干端口加上相应的控制逻辑电路组成接口。通常，**CPU能对数据端口进行读写操作，但对状态端口只能执行读状态，对控制端口只能执行写操作**。

&emsp;&emsp;I/O端口要想被CPU访问，必须要有端口地址，每个端口对应一个端口地址。而对I/O端口的编制方式有**与存储器统一编制**和**独立编制**两种。

<img src="./组成原理/7.3.4-1.png" alt="7.3.4-1" style="zoom:80%;" />



### 7.4 I/O方式

#### 7.4.1 程序查询方式

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2011-22</font>

&emsp;&emsp;信息交换的控制完全由主机执行程序实现，程序查询方式接口中设置一个**数据缓冲寄存器(数据端口)**和一个**设备状态寄存器(状态端口)**。主机进行I/O操作时，先发出查询信号，读取设备的状态并根据设备状态决定下一步操作究竟是进行数据传送还是等待。

- **程序查询方式的工作流程**

<img src="./组成原理/7.4.1-1.png" alt="7.4.1-1" style="zoom:80%;" />

&emsp;&emsp;在这种控制方式下，CPU一旦启动I/O，就必须停止现行程序的运行，并在现行程序中插入一段程序。程序查询方式的特点是**CPU有“踏步”等待现象，CPU与I/O串行工作**。这种方式的**接口设计简单、设备量少**，但CPU在信息传送过程中要**花费很多时间来查询和等待**，而且**在一段时间内只能和一台外部设备交换信息，效率大大降低**。

<img src="./组成原理/7.4.1-2.png" alt="7.4.1-2" style="zoom:80%;" />





#### 7.4.2 程序中断方式

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2009-43,2012-43,2016-44</font>

##### 1. 程序中断的基本概念

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2014-22</font>

&emsp;&emsp;程序中断是指在计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊请求，**CPU暂时中止现行程序，而转去对这些异常情况或特殊情况进行处理，在处理完毕后CPU又自动返回到现行程序的断点处**，继续执行原程序。

- **程序中断的作用**

<img src="./组成原理/7.4.2-3.png" alt="7.4.2-3" style="zoom:80%;" />

- **程序中断处理方式的思想**

&emsp;&emsp;CPU在程序中安排好某个时刻启动某台外设，然后CPU继续执行原来的程序，不需要像查询方式那样一直等待外设准备就绪。一旦外设完成数据传送的准备工作，就主动向CPU发出中断请求，请求CPU为自己服务。在可以响应中断的条件下，CPU暂停正在执行的程序，转去执行中断服务程序为外设服务，在中断服务程序中完成一次主机与外设之间的数据传送，传送完成后，CPU返回原来的程序。

<img src="./组成原理/7.4.2-4.png" alt="7.4.2-4" style="zoom:80%;" />



##### 2. 程序中断方式工作流程

**（1）中断请求**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-22</font>

中断请求是中断源向CPU发出中断请求信号。

① **内中断** VS **外中断**

- **外中断**：指来自处理器和内存以外的部件引起的中断，包括**I/O设备发出的I/O中断**、**外部信号中断(Esc建)**，以及各种定时器引起的时钟中断等。
- **内中断**：指在处理器和内存内部产生的中断，包括程序运算引起的各种错误，如**地址非法、校验错、页面失效、存取访问控制错、算术操作溢出、数据格式非法、除数为零、非法指令、用户程序执行特权指令、分时系统中的时间片中断及用户态到核心态的切换**等。

② **硬件中断** VS **软件中断**

- **硬件中断**：通过外部的硬件产生的中断。**硬件中断属于外中断**。
- **软件中断**：通过某条指令产生的中断，这种中断可以编程实现。**软件中断是内中断**。

③ **非屏蔽中断** VS **可屏蔽中断**

- **非屏蔽中断**：**非屏蔽中断是一种硬件中断**，这种中断通过不可中断请求NMI控制，不受中断标志位IF的影响，即使在关中断(IF = 0)的情况下也会被响应。
- **屏蔽中断**：**可屏蔽中断也是一种硬件中断**，此种中断通过中断请求标记触发器INTR控制，且受中断标志位IF的影响，在关中断情况下不接受中断请求。

也就是说，**可屏蔽中断和非屏蔽中断均是外部中断**。



**（4）中断隐指令**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2012-22</font>

&emsp;&emsp;CPU响应中断后，经过某些操作，转去执行中断服务程序。这些操作是由**硬件直接实现**的，将它称为中断隐指令。

&emsp;&emsp;中断隐指令并**不是指令系统中一条真正的指令**，它没有操作码，所以中断隐指令是一种不允许也不可能为用户使用的特殊指令。它所完成的操作如下

①**关中断**：在中断服务程序中，为了保护中断现场(即CPU主要寄存器中的内容)期间不被新的中断所打断，必须关中断。

②**保存断点**：为保证在中断服务程序执行完毕后能正确返回到原来的程序，必须将原来的断点(即**程序计数器PC的内容**)保存起来。

③**引出中断服务程序**：引出中断服务程序的实质是，取出中断服务程序的入口地址并传送给程序计数器(PC)。



**（6）中断处理过程**

- **允许嵌套中断的处理流程**

<img src="./组成原理/7.4.2-1.png" alt="7.4.2-1" style="zoom:90%;" />

- **不允许嵌套中断的处理流程**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2010-21</font>

1）关中断 -> 2）保存断点 -> 3）识别中断源 -> 4）保护现场 -> 5）中断处理事件 -> 6）恢复现场 -> 7）开中断 -> 8）中断返回

**【注】**不允许嵌套中断的处理流程中**少了在恢复现场过程中的关中断和开中断**。



##### 3. 多重中断和中断屏蔽技术

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2011-21,2017-22</font>

&emsp;&emsp;若CPU在执行中断服务程序的过程中，又出现了新的更高优先级的中断毕业，而CPU对新的中断请求不予响应，这种中断称为单重中断，如图7.7(a)。若CPU暂停现行的中断服务程序，转去处理新的中断响应，则这种中断称为多重中断，又称为中断嵌套，如图：

<img src="./组成原理/7.4.2-2.png" alt="7.4.2-2" style="zoom:80%;" />

&emsp;&emsp;中断屏蔽技术主要用于多重中断。CPU要具备多重中断的功能，必须满足下列条件：

① 在中断服务程序中提前设置开中断指令。

② 优先级别高的中断源有权中断优先级别低的中断源。

&emsp;&emsp;每个中断源都有一个屏蔽触发器，1表示屏蔽该中断源的请求，0表示可以正常申请，所有屏蔽触发器组合在一起便构成了一个**屏蔽字寄存器**，屏蔽字寄存器的内容称为**屏蔽字**。

**【注】**多重中断系统在保护被中断进程现场时关中断，执行中断处理程序时开中断。



#### 7.4.3 DMA方式

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2009-43,2012-43</font>

&emsp;&emsp;DMA方式是一种**完全由硬件进行成组信息传送**的控制方式，它具有程序中断的优点，即**在数据准备阶段，CPU与外设并行工作**。DMA方式在外设和内存之间开辟一条“直接数据通道”，**信息传送不经过CPU(只有开始和结束的时候才需要CPU)**，降低了CPU在传送数据时的开销，因此称为直接存储器存取方式。

&emsp;&emsp;这种方式**适用于磁盘机、磁带机等高速设备大批量数据的传送**，它的硬件开销比较大。在DMA方式中，中断的作用仅限于故障和正常传送结束时的处理。

1. **DMA方式的特点**

<img src="./组成原理/7.4.3-1.png" alt="7.4.3-1" style="zoom:80%;" />

2. **DMA控制器的组成**

&emsp;&emsp;在DMA方式中，**对数据传送过程进行控制的硬件**称为DMA控制器(DMA接口)。当I/O设备需要进行数据传送时，通过DMA控制器向CPU提出DMA传送请求，**CPU响应之后将让出系统总线**，由DMA控制器接管总线进行数据传送。其主要功能如下：

<img src="./组成原理/7.4.3-2.png" alt="7.4.3-2" style="zoom:80%;" />

- **简单的DMA控制器结构图**

<img src="./组成原理/7.4.3-3.png" alt="7.4.3-3" style="zoom:80%;" />

相关的部件：<img src="./组成原理/7.4.3-4.png" alt="7.4.3-4" style="zoom:80%;" />

【注】**在DMA传送过程中，DMA控制器将接管CPU的地址总线、数据总线和控制总线**，CPU的主存控制信号被禁止使用。而当DMA传送结束后，将恢复CPU的一切权利并开始执行其操作，由此可见，**DMA控制器必须具备有控制总线的能力**。

3. **DMA的传输方式**

&emsp;&emsp;主存和DMA控制器之间有一条数据通路，因此主存和I/O设备之间交换信息时，不通过CPU。但当I/O设备和CPU同时访问主存时，可能发生冲突，为了有效地使用主存，DMA控制器与CPU通常采用以下3种方式使用主存。

<img src="./组成原理/7.4.3-5.png" alt="7.4.3-5" style="zoom:80%;" />

<img src="./组成原理/7.4.3-6.png" alt="7.4.3-6" style="zoom:78%;" />

4. **DMA的传送过程**

<img src="./组成原理/7.4.3-7.png" alt="7.4.3-7" style="zoom:80%;" />

<img src="./组成原理/7.4.3-8.png" alt="7.4.3-8" style="zoom:80%;" />

5. **DMA方式和中断方式的区别**

<img src="./组成原理/7.4.3-9.png" alt="7.4.3-9" style="zoom:80%;" />

